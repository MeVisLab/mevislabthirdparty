diff --git i/dcmnet/apps/storescp.cc w/dcmnet/apps/storescp.cc
index 78ff960..c52a124 100644
--- i/dcmnet/apps/storescp.cc
+++ w/dcmnet/apps/storescp.cc
@@ -115,11 +115,15 @@ enum E_SortStudyMode
     ESM_None,
     ESM_Timestamp,
     ESM_StudyInstanceUID,
-    ESM_PatientName
+    ESM_PatientName,
+    ESM_CallingAET
 };
 
 OFBool             opt_showPresentationContexts = OFFalse;
 OFBool             opt_uniqueFilenames = OFFalse;
+OFBool             opt_addCalledAETtoPath = OFFalse;
+OFBool             opt_flatStudyPath = OFFalse;
+OFBool             opt_tempfileWhileSaving = OFFalse;
 OFString           opt_fileNameExtension;
 OFBool             opt_timeNames = OFFalse;
 int                timeNameCounter = -1;   // "serial number" to differentiate between files with same timestamp
@@ -176,6 +180,7 @@ OFBool             opt_forkMode = OFFalse;
 
 OFBool             opt_forkedChild = OFFalse;
 OFBool             opt_execSync = OFFalse;            // default: execute in background
+OFBool             opt_shortInfo = OFFalse;           // default: use standard logging options
 
 
 #ifdef HAVE_WAITPID
@@ -205,6 +210,100 @@ extern "C" void sigChildHandler(int)
 #define SHORTCOL 4
 #define LONGCOL 21
 
+class ShortInfo
+{
+public:
+  /* default constructor */
+  ShortInfo();
+  /* add a string to the current short info */
+  void add(const OFString& s);
+  /* print the accumulated short info and clear it */
+  void print();
+  /* add association info to short info */
+  void addAssociationInfo(T_ASC_Association *assoc, int success);
+  /* sets the port used for the association */
+  void setPort(int port);
+
+private:
+  /* the accumulated info that shall be output on next call to print() */
+  OFString _shortInfo;
+  /* the port used for the association */
+  int _port;
+};
+
+ShortInfo short_info;
+
+ShortInfo::ShortInfo()
+: _port(0)
+{
+}
+
+void ShortInfo::setPort(int port)
+{
+  _port = port;
+}
+
+void ShortInfo::add(const OFString& s)
+{
+  _shortInfo += s;
+}
+
+void ShortInfo::print()
+{
+  // we use forcedLog to be independent from the log level
+  storescpLogger.forcedLog( OFLogger::INFO_LOG_LEVEL, _shortInfo );
+  _shortInfo.clear();
+}
+
+void ShortInfo::addAssociationInfo(T_ASC_Association *assoc, int success)
+{
+  // get current time
+#ifdef HAVE_WINDOWS_H
+  SYSTEMTIME timebuf;
+  GetLocalTime(&timebuf);
+  int year = timebuf.wYear;
+  int month = timebuf.wMonth;
+  int day = timebuf.wDay;
+  int hour = timebuf.wHour;
+  int min = timebuf.wMinute;
+  int sec = timebuf.wSecond;
+  int centisec = (int)timebuf.wMilliseconds / 10;
+#define snprintf _snprintf
+#else
+  struct timeval tv;
+  gettimeofday(&tv, NULL);
+  time_t tt = time(NULL);
+  tm *tVal = localtime( &tt );
+  int year = tVal->tm_year + 1900;
+  int month = tVal->tm_mon + 1;
+  int day = tVal->tm_mday;
+  int hour = tVal->tm_hour;
+  int min = tVal->tm_min;
+  int sec = tVal->tm_sec;
+  int centisec = (int)(tv.tv_usec / 100);
+#endif
+
+  if (success)
+  {
+    add("ACC ");
+  }
+  else
+  {
+    add("REJ ");
+  }
+
+  char info[100];
+  snprintf(info, 100, "(%s %s) (%s,%d) %4d%02d%02d %02d%02d%02d.%02d ",
+    assoc->params->DULparams.callingAPTitle,
+    assoc->params->DULparams.callingPresentationAddress,
+    assoc->params->DULparams.calledAPTitle,
+    _port,
+    year, month, day, hour, min, sec, centisec);
+
+  add(info);
+}
+
+
 int main(int argc, char *argv[])
 {
   T_ASC_Network *net;
@@ -231,6 +330,7 @@ int main(int argc, char *argv[])
     cmd.addOption("--version",                             "print version information and exit", OFCommandLine::AF_Exclusive);
     OFLog::addOptions(cmd);
     cmd.addOption("--verbose-pc",               "+v",      "show presentation contexts in verbose mode");
+    cmd.addOption("--short-info",               "-si",     "print short info for each association request");
 
 #if defined(HAVE_FORK) || defined(_WIN32)
   cmd.addGroup("multi-process options:", LONGCOL, SHORTCOL + 2);
@@ -354,12 +454,17 @@ int main(int argc, char *argv[])
       cmd.addOption("--sort-on-study-uid",      "-su",  1, "[p]refix: string",
                                                            "sort studies using prefix p and the Study\nInstance UID");
       cmd.addOption("--sort-on-patientname",    "-sp",     "sort studies using the Patient's Name and\na timestamp");
+      cmd.addOption("--sort-on-callingAET",     "-sc",     "sort studies using calling AET as subdirectory");
+
     cmd.addSubGroup("filename generation:");
       cmd.addOption("--default-filenames",      "-uf",     "generate filename from instance UID (default)");
       cmd.addOption("--unique-filenames",       "+uf",     "generate unique filenames");
       cmd.addOption("--timenames",              "-tn",     "generate filename from creation time");
       cmd.addOption("--filename-extension",     "-fe",  1, "[e]xtension: string",
                                                            "append e to all filenames");
+      cmd.addOption("--flat-study-path",        "-fp",     "do not create sub directories for studies ");
+      cmd.addOption("--tempfile-while-saving",  "-st",     "save to temp file and rename afterwards");
+      cmd.addOption("--add-called-AET",         "-ae",     "add the called AET in the path");
 
   cmd.addGroup("event options:", LONGCOL, SHORTCOL + 2);
     cmd.addOption("--exec-on-reception",        "-xcr", 1, "[c]ommand: string",
@@ -478,6 +583,10 @@ int main(int argc, char *argv[])
       app.checkDependence("--verbose-pc", "verbose mode", storescpLogger.isEnabledFor(OFLogger::INFO_LOG_LEVEL));
       opt_showPresentationContexts = OFTrue;
     }
+    if (cmd.findOption("--short-info"))
+    {
+      opt_shortInfo = OFTrue;
+    }
 
     cmd.beginOptionBlock();
     if (cmd.findOption("--prefer-uncompr"))
@@ -822,12 +931,20 @@ int main(int argc, char *argv[])
       opt_sortStudyDirPrefix = NULL;
       opt_sortStudyMode = ESM_PatientName;
     }
+    if (cmd.findOption("--sort-on-callingAET"))
+    {
+      opt_sortStudyMode = ESM_CallingAET;
+    }
+
     cmd.endOptionBlock();
 
     cmd.beginOptionBlock();
     if (cmd.findOption("--default-filenames")) opt_uniqueFilenames = OFFalse;
     if (cmd.findOption("--unique-filenames")) opt_uniqueFilenames = OFTrue;
     cmd.endOptionBlock();
+    if (cmd.findOption("--add-called-AET")) opt_addCalledAETtoPath = OFTrue;
+    if (cmd.findOption("--flat-study-path")) opt_flatStudyPath = OFTrue;
+    if (cmd.findOption("--tempfile-while-saving")) opt_tempfileWhileSaving = OFTrue;
 
     if (cmd.findOption("--timenames")) opt_timeNames = OFTrue;
     if (cmd.findOption("--filename-extension"))
@@ -1077,6 +1194,8 @@ static OFCondition acceptAssociation(T_ASC_Network *net, DcmAssociationConfigura
     goto cleanup;
   }
 
+  short_info.setPort(net->acceptorPort);
+
 #if defined(HAVE_FORK) || defined(_WIN32)
   if (opt_forkMode)
     OFLOG_INFO(storescpLogger, "Association Received in " << (DUL_processIsForkedChild() ? "child" : "parent")
@@ -1101,6 +1220,11 @@ static OFCondition acceptAssociation(T_ASC_Network *net, DcmAssociationConfigura
     };
 
     OFLOG_INFO(storescpLogger, "Refusing Association (forced via command line)");
+    if (opt_shortInfo)
+    {
+      short_info.addAssociationInfo(assoc, OFFalse);
+      short_info.print();
+    }
     cond = ASC_rejectAssociation(assoc, &rej);
     if (cond.bad())
     {
@@ -1396,6 +1520,11 @@ static OFCondition acceptAssociation(T_ASC_Network *net, DcmAssociationConfigura
     };
 
     OFLOG_INFO(storescpLogger, "Association Rejected: Bad Application Context Name: " << buf);
+    if (opt_shortInfo)
+    {
+      short_info.addAssociationInfo(assoc, OFFalse);
+      short_info.print();
+    }
     cond = ASC_rejectAssociation(assoc, &rej);
     if (cond.bad())
     {
@@ -1415,6 +1544,11 @@ static OFCondition acceptAssociation(T_ASC_Network *net, DcmAssociationConfigura
     };
 
     OFLOG_INFO(storescpLogger, "Association Rejected: No Implementation Class UID provided");
+    if (opt_shortInfo)
+    {
+      short_info.addAssociationInfo(assoc, OFFalse);
+      short_info.print();
+    }
     cond = ASC_rejectAssociation(assoc, &rej);
     if (cond.bad())
     {
@@ -1433,6 +1567,10 @@ static OFCondition acceptAssociation(T_ASC_Network *net, DcmAssociationConfigura
       OFLOG_ERROR(storescpLogger, DimseCondition::dump(temp_str, cond));
       goto cleanup;
     }
+    if (opt_shortInfo)
+    {
+      short_info.addAssociationInfo(assoc, OFTrue);
+    }
     OFLOG_INFO(storescpLogger, "Association Acknowledged (Max Send PDV: " << assoc->sendPDVLength << ")");
     if (ASC_countAcceptedPresentationContexts(assoc->params) == 0)
       OFLOG_INFO(storescpLogger, "    (but no valid presentation contexts)");
@@ -1537,6 +1675,7 @@ processCommands(T_ASC_Association * assoc)
   T_DIMSE_Message msg;
   T_ASC_PresentationContextID presID = 0;
   DcmDataset *statusDetail = NULL;
+  bool loggedAssocType = false;
 
   // start a loop to be able to receive more than one DIMSE command
   while( cond == EC_Normal || cond == DIMSE_NODATAAVAILABLE || cond == DIMSE_OUTOFRESOURCES )
@@ -1599,15 +1738,27 @@ processCommands(T_ASC_Association * assoc)
       {
         case DIMSE_C_ECHO_RQ:
           // process C-ECHO-Request
+          if (opt_shortInfo && !loggedAssocType)
+          {
+            short_info.add("C-ECHO");
+          }
           cond = echoSCP(assoc, &msg, presID);
           break;
         case DIMSE_C_STORE_RQ:
           // process C-STORE-Request
+          if (opt_shortInfo && !loggedAssocType)
+          {
+            short_info.add("C-STORE");
+          }
           cond = storeSCP(assoc, &msg, presID);
           break;
         default:
           OFString tempStr;
           // we cannot handle this kind of message
+          if (opt_shortInfo && !loggedAssocType)
+          {
+            short_info.add("UNSUPPORTED");
+          }
           cond = DIMSE_BADCOMMANDTYPE;
           OFLOG_ERROR(storescpLogger, "Expected C-ECHO or C-STORE request but received DIMSE command 0x"
                << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(4)
@@ -1768,7 +1919,7 @@ storeSCPCallback(
     // is present and the options opt_bitPreserving and opt_ignore are not set.
     if ((imageDataSet != NULL) && (*imageDataSet != NULL) && !opt_bitPreserving && !opt_ignore)
     {
-      OFString fileName;
+      OFString fileName, newFileName;
 
       // in case one of the --sort-xxx options is set, we need to perform some particular steps to
       // determine the actual name of the output file
@@ -1817,7 +1968,8 @@ storeSCPCallback(
         // if this is the first DICOM object that was received or if the study instance UID in the
         // current DICOM object does not equal the last object's study instance UID we need to create
         // a new subdirectory in which the current DICOM object will be stored
-        if (lastStudyInstanceUID.empty() || (lastStudyInstanceUID != currentStudyInstanceUID))
+        if (opt_flatStudyPath == OFFalse &&
+            (lastStudyInstanceUID.empty() || (lastStudyInstanceUID != currentStudyInstanceUID)))
         {
           // if lastStudyInstanceUID is non-empty, we have just completed receiving all objects for one
           // study. In such a case, we need to set a certain indicator variable (lastStudySubdirectoryPathAndName),
@@ -1864,6 +2016,12 @@ storeSCPCallback(
               subdirectoryName += '_';
               subdirectoryName += timestamp;
               break;
+            case ESM_CallingAET:
+              subdirectoryName = callingAETitle;
+              subdirectoryName = replaceChars( subdirectoryName, "\"", "" );
+              subdirectoryName = replaceChars( subdirectoryName, "/", "_" );
+              subdirectoryName = replaceChars( subdirectoryName, ":", "_" );
+              break;
             case ESM_None:
               break;
           }
@@ -1873,19 +2031,23 @@ storeSCPCallback(
 
           // check if the subdirectory already exists
           // if it already exists dump a warning
-          if( OFStandard::dirExists(subdirectoryPathAndName) )
-            OFLOG_WARN(storescpLogger, "subdirectory for study already exists: " << subdirectoryPathAndName);
+          if( OFStandard::dirExists(subdirectoryPathAndName) ) {
+              if (opt_sortStudyMode != ESM_CallingAET)
+              {
+                OFLOG_WARN(storescpLogger, "subdirectory already exists: " << subdirectoryPathAndName);
+              }
+          }
           else
           {
             // if it does not exist create it
-            OFLOG_INFO(storescpLogger, "creating new subdirectory for study: " << subdirectoryPathAndName);
+            OFLOG_INFO(storescpLogger, "creating new subdirectory: " << subdirectoryPathAndName);
 #ifdef HAVE_WINDOWS_H
             if( _mkdir( subdirectoryPathAndName.c_str() ) == -1 )
 #else
             if( mkdir( subdirectoryPathAndName.c_str(), S_IRWXU | S_IRWXG | S_IRWXO ) == -1 )
 #endif
             {
-              OFLOG_ERROR(storescpLogger, "could not create subdirectory for study: " << subdirectoryPathAndName);
+              OFLOG_ERROR(storescpLogger, "could not create subdirectory: " << subdirectoryPathAndName);
               rsp->DimseStatus = STATUS_STORE_Error_CannotUnderstand;
               return;
             }
@@ -1901,6 +2063,13 @@ storeSCPCallback(
         // path and file name; however, the path refers to the output directory captured in opt_outputDirectory)
         OFStandard::combineDirAndFilename(fileName, subdirectoryPathAndName, OFStandard::getFilenameFromPath(tmpStr, cbdata->imageFileName));
 
+        if(opt_tempfileWhileSaving)
+        {
+          newFileName = fileName;
+          // add an extension which stands for "to be processed"
+          fileName += ".tbp";
+        }
+
         // update global variable outputFileNameArray
         // (might be used in executeOnReception() and renameOnEndOfStudy)
         outputFileNameArray.push_back(tmpStr);
@@ -1909,7 +2078,12 @@ storeSCPCallback(
       else
       {
         fileName = cbdata->imageFileName;
-
+        if(opt_tempfileWhileSaving)
+        {
+          newFileName = fileName;
+          // add an extension which stands for "to be processed"
+          fileName += ".tbp";
+        }
         // update global variables outputFileNameArray
         // (might be used in executeOnReception() and renameOnEndOfStudy)
         outputFileNameArray.push_back(OFStandard::getFilenameFromPath(tmpStr, fileName));
@@ -1937,6 +2111,14 @@ storeSCPCallback(
         OFStandard::deleteFile(fileName);
       }
 
+      if(opt_tempfileWhileSaving)
+      {
+        newFileName += ".dcm";
+        // if the file already exists, delete it
+        unlink(newFileName.c_str());
+        rename(fileName.c_str(), newFileName.c_str());
+      }
+
       // check the image to make sure it is consistent, i.e. that its sopClass and sopInstance correspond
       // to those mentioned in the request. If not, set the status in the response message variable.
       if (rsp->DimseStatus == STATUS_Success)
@@ -1961,13 +2143,42 @@ storeSCPCallback(
     // in case opt_bitPreserving is set, do some other things
     if( opt_bitPreserving )
     {
+      OFString newFileName = cbdata->imageFileName;
+      if (opt_tempfileWhileSaving)
+      {
+        newFileName += ".dcm";
+        // if the file already exists, delete it
+        unlink(newFileName.c_str());
+        OFString oldFileName = cbdata->imageFileName;
+        oldFileName += ".tbp";
+        rename(oldFileName.c_str(), newFileName.c_str());
+      }
       // we need to set outputFileNameArray and outputFileNameArrayCnt to be
       // able to perform the placeholder substitution in executeOnReception()
-      outputFileNameArray.push_back(OFStandard::getFilenameFromPath(tmpStr, cbdata->imageFileName));
+      outputFileNameArray.push_back(OFStandard::getFilenameFromPath(tmpStr, newFileName.c_str()));
     }
   }
 }
 
+static void sanitizeAET(DIC_AE &aet)
+{
+  size_t len = strlen(aet);
+  for( size_t i = 0 ; i < len ; i++ )
+  {
+    /* make all lowercase characters upppercase */
+    if (islower(aet[i]))
+    {
+      aet[i] = toupper(aet[i]);
+    }
+    /* all uppercase chars and all digits are ok. */
+    if (isupper(aet[i]) || isdigit(aet[i]))
+    {
+      continue;
+    }
+    /* Anything else gets mapped to underscores. */
+    aet[i] = '_';
+	}
+}
 
 static OFCondition storeSCP(
   T_ASC_Association *assoc,
@@ -2005,13 +2216,24 @@ static OFCondition storeSCP(
   }
   else
   {
+    OFString pathPrefix = opt_outputDirectory;
+    if (opt_addCalledAETtoPath )
+    {
+      DIC_AE callingTitle;
+      DIC_AE calledTitle;
+      if (ASC_getAPTitles(assoc->params, callingTitle, sizeof(callingTitle), calledTitle, sizeof(calledTitle), NULL, 0).good()) {
+        sanitizeAET(calledTitle);
+        pathPrefix += PATH_SEPARATOR;
+        pathPrefix += calledTitle;
+      }
+    }
     // 3 possibilities: create unique filenames (fn), create timestamp fn, create fn from SOP Instance UIDs
     if (opt_uniqueFilenames)
     {
       // create unique filename by generating a temporary UID and using ".X." as an infix
       char buf[70];
       dcmGenerateUniqueIdentifier(buf);
-      sprintf(imageFileName, "%s%c%s.X.%s%s", opt_outputDirectory.c_str(), PATH_SEPARATOR, dcmSOPClassUIDToModality(req->AffectedSOPClassUID, "UNKNOWN"),
+      sprintf(imageFileName, "%s%c%s.X.%s%s", pathPrefix.c_str(), PATH_SEPARATOR, dcmSOPClassUIDToModality(req->AffectedSOPClassUID, "UNKNOWN"),
         buf, opt_fileNameExtension.c_str());
     }
     else if (opt_timeNames)
@@ -2044,7 +2266,7 @@ static OFCondition storeSCP(
         // if this is not the first run and the prospective filename is equal to the last written filename
         // generate one with a serial number (incremented by 1)
         timeNameCounter++;
-        sprintf(imageFileName, "%s%c%04u%02u%02u%02u%02u%02u%03u_%04u.%s%s", opt_outputDirectory.c_str(), PATH_SEPARATOR, // millisecond version
+        sprintf(imageFileName, "%s%c%04u%02u%02u%02u%02u%02u%03u_%04u.%s%s", pathPrefix.c_str(), PATH_SEPARATOR, // millisecond version
           dateTime.getDate().getYear(), dateTime.getDate().getMonth(), dateTime.getDate().getDay(),
           dateTime.getTime().getHour(), dateTime.getTime().getMinute(), dateTime.getTime().getIntSecond(), dateTime.getTime().getMilliSecond(),
           timeNameCounter, dcmSOPClassUIDToModality(req->AffectedSOPClassUID, "UNKNOWN"), opt_fileNameExtension.c_str());
@@ -2052,7 +2274,7 @@ static OFCondition storeSCP(
       else
       {
         // first run or filenames are different: create filename without serial number
-        sprintf(imageFileName, "%s%c%04u%02u%02u%02u%02u%02u%03u.%s%s", opt_outputDirectory.c_str(), PATH_SEPARATOR, // millisecond version
+        sprintf(imageFileName, "%s%c%04u%02u%02u%02u%02u%02u%03u.%s%s", pathPrefix.c_str(), PATH_SEPARATOR, // millisecond version
           dateTime.getDate().getYear(), dateTime.getDate().getMonth(), dateTime.getDate().getDay(),
           dateTime.getTime().getHour(), dateTime.getTime().getMinute(),dateTime.getTime().getIntSecond(), dateTime.getTime().getMilliSecond(),
           dcmSOPClassUIDToModality(req->AffectedSOPClassUID, "UNKNOWN"), opt_fileNameExtension.c_str());
@@ -2063,7 +2285,7 @@ static OFCondition storeSCP(
     else
     {
       // don't create new UID, use the study instance UID as found in object
-      sprintf(imageFileName, "%s%c%s.%s%s", opt_outputDirectory.c_str(), PATH_SEPARATOR, dcmSOPClassUIDToModality(req->AffectedSOPClassUID, "UNKNOWN"),
+      sprintf(imageFileName, "%s%c%s.%s%s", pathPrefix.c_str(), PATH_SEPARATOR, dcmSOPClassUIDToModality(req->AffectedSOPClassUID, "UNKNOWN"),
         req->AffectedSOPInstanceUID, opt_fileNameExtension.c_str());
     }
   }
@@ -2101,7 +2323,13 @@ static OFCondition storeSCP(
   // DIMSE_storeProvider must be called with certain parameters.
   if (opt_bitPreserving)
   {
-    cond = DIMSE_storeProvider(assoc, presID, req, imageFileName, opt_useMetaheader, NULL,
+    OFString fileName = imageFileName;
+    if(opt_tempfileWhileSaving)
+    {
+      // add an extension which stands for "to be processed"
+      fileName += ".tbp";
+    }
+    cond = DIMSE_storeProvider(assoc, presID, req, fileName.c_str(), opt_useMetaheader, NULL,
       storeSCPCallback, &callbackData, opt_blockMode, opt_dimse_timeout);
   }
   else
