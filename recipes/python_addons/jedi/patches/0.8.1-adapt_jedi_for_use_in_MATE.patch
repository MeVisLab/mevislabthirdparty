diff --git i/jedi/_compatibility.py w/jedi/_compatibility.py
index 61c6d95..b1445c1 100644
--- i/jedi/_compatibility.py
+++ w/jedi/_compatibility.py
@@ -54,7 +54,9 @@ def find_module_pre_py33(string, path=None):
     return module_file, module_path, module_type is imp.PKG_DIRECTORY
 
 
-find_module = find_module_py33 if is_py33 else find_module_pre_py33
+#find_module = find_module_py33 if is_py33 else find_module_pre_py33
+# we use the old find module because e.g. PythonQt.QtCore could not be found by the new mechanism...
+find_module = find_module_pre_py33
 find_module.__doc__ = """
 Provides information about a module.
 
@@ -175,12 +177,11 @@ def u(string):
         return unicode(str(string), 'UTF-8')
     return string
 
-try:
+if is_py3:
     import builtins  # module name in python 3
-except ImportError:
+else:
     import __builtin__ as builtins
 
-
 import ast
 
 
diff --git i/jedi/api/__init__.py w/jedi/api/__init__.py
index 1aa73f7..acb25c1 100644
--- i/jedi/api/__init__.py
+++ w/jedi/api/__init__.py
@@ -675,12 +675,13 @@ class Interpreter(Script):
             for namespace in namespaces:
                 for name in dir(namespace):
                     if name.lower().startswith(like.lower()):
-                        scope = self._parser.module()
+                        # MEVIS: fix lookup of builtins to get correct type
+                        parserScope = self._parser.module()
+                        scope = compiled.CompiledObject(getattr(namespace, name), parserScope)
                         n = FakeName(name, scope)
                         completions.append((n, scope))
             return completions
 
-
 def defined_names(source, path=None, encoding='utf-8'):
     """
     Get all definitions in `source` sorted by its position.
diff --git i/jedi/api/classes.py w/jedi/api/classes.py
index ec8d725..3fb6fa4 100644
--- i/jedi/api/classes.py
+++ w/jedi/api/classes.py
@@ -711,7 +711,8 @@ class CallSignature(Definition):
                 # *args case
                 if param._definition.stars == 1:
                     return i
-            return None
+            # MEVIS: return index even if out of bounds, because not all signatures are known correctly...
+            return self._index
         return self._index
 
     @property
diff --git i/jedi/evaluate/compiled/__init__.py w/jedi/evaluate/compiled/__init__.py
index 3ae14f7..1adce8e 100644
--- i/jedi/evaluate/compiled/__init__.py
+++ w/jedi/evaluate/compiled/__init__.py
@@ -14,6 +14,7 @@ from jedi.parser.representation import Param, SubModule, Base, IsScope, Operator
 from jedi.evaluate.helpers import FakeName
 from . import fake
 
+from jedi import settings
 
 _sep = os.path.sep
 if os.path.altsep is not None:
@@ -65,6 +66,12 @@ class CompiledObject(Base):
 
     def type(self):
         cls = self._cls().obj
+        # MEVIS extra handling for slots
+        try:
+          if cls.__class__.__name__ == 'builtin_qt_slot':
+              return 'function'
+        except:
+          pass
         if inspect.isclass(cls):
             return 'class'
         elif inspect.ismodule(cls):
@@ -93,7 +100,8 @@ class CompiledObject(Base):
         if inspect.ismodule(self.obj):
             return self.instance_names()
         else:
-            return type_names + self.instance_names()
+            # MEVIS: it is important to return type_names last, so that implemented methods like __init__ have the correct parent!
+            return self.instance_names() + type_names
 
     def scope_names_generator(self, position=None):
         yield self, self.get_defined_names()
@@ -151,10 +159,41 @@ class CompiledObject(Base):
     def execute_function(self, evaluator, params):
         if self.type() != 'function':
             return
+        
+        try:
+          instanceName = self.parent._mlabInstanceName
+        except:
+          instanceName = None
 
         for name in self._parse_function_doc()[1].split():
+            # MEVIS: support for instanceNames and specialized return type
+            lookupName = instanceName
+            if len(params):
+                param1 = params[0].get_code().strip()
+                if (param1.startswith("'") and param1.endswith("'")) or (param1.startswith('"') and param1.endswith('"')):
+                    lookupName = param1[1:-1]
+                    if instanceName:
+                        lookupName = instanceName + "." + lookupName
+                else:
+                    lookupName = None
+            if lookupName and hasattr(settings, "AdvancedTypeLookup"):
+              returnType = settings.AdvancedTypeLookup.lookupReturnType(self.parent.name, self.name, lookupName)
+              if returnType:
+                  name = returnType            
+            # MEVIS: support for Package.Module.Class in builtin return values
+            parts = name.split(".")
+            mod = builtin
+            if len(parts)>1:
+                moduleName = '.'.join(parts[:-1])
+                name = parts[-1]
+                import jedi.evaluate.imports as imports
+                mod = imports._load_module(name = moduleName)
             try:
-                bltn_obj = _create_from_name(builtin, builtin, name)
+                bltn_obj = _create_from_name(mod, mod, name)
+                # MEVIS: store instance name via params
+                if lookupName:
+                  bltn_obj._mlabInstanceName = lookupName
+                    
             except AttributeError:
                 continue
             else:
@@ -192,9 +231,9 @@ class CompiledObject(Base):
         return []  # Builtins don't have imports
 
     def is_callable(self):
-        """Check if the object has a ``__call__`` method."""
-        return hasattr(self.obj, '__call__')
-
+        """Check if the object is callable"""
+        # MEVIS: use callable, because vtk wrappers don't have a __call__ method
+        return callable(self.obj)
 
 class CompiledName(FakeName):
     def __init__(self, obj, name):
@@ -283,8 +322,10 @@ def load_module(path, name):
     if dotted_path is None:
         p, _, dotted_path = path.partition(os.path.sep)
         sys_path.insert(0, p)
-
     temp, sys.path = sys.path, sys_path
+    # MEVIS: in debug mode, the DLL ends with _d, we need to remove that:
+    if dotted_path.endswith("_d"):
+      dotted_path = dotted_path[:-2]
     __import__(dotted_path)
     # Just access the cache after import, because of #59 as well as the very
     # complicated import structure of Python.
@@ -358,7 +399,6 @@ def _parse_function_doc(doc):
         ret_str = re.sub(r'[nN]ew (.*)', r'\1()', ret_str)
 
         ret = docstr_defaults.get(ret_str, ret_str)
-
     return param_str, ret
 
 
diff --git i/jedi/evaluate/compiled/fake.py w/jedi/evaluate/compiled/fake.py
index d9d2285..fdca42d 100644
--- i/jedi/evaluate/compiled/fake.py
+++ w/jedi/evaluate/compiled/fake.py
@@ -110,7 +110,10 @@ def get_faked(module, obj, name=None):
 
 def is_class_instance(obj):
     """Like inspect.* methods."""
-    return not (inspect.isclass(obj) or inspect.ismodule(obj)
+    try:
+      return not (inspect.isclass(obj) or inspect.ismodule(obj)
                 or inspect.isbuiltin(obj) or inspect.ismethod(obj)
                 or inspect.ismethoddescriptor(obj) or inspect.iscode(obj)
-                or inspect.isgenerator(obj))
+                or inspect.isgenerator(obj) or (obj.__class__.__name__ == 'builtin_qt_slot'))
+    except:
+      return False
diff --git i/jedi/evaluate/docstrings.py w/jedi/evaluate/docstrings.py
index 9a789a5..1041cf0 100644
--- i/jedi/evaluate/docstrings.py
+++ w/jedi/evaluate/docstrings.py
@@ -21,6 +21,7 @@ from textwrap import dedent
 from jedi.evaluate.cache import memoize_default
 from jedi.parser import Parser
 from jedi.common import indent_block
+from jedi import settings
 
 DOCSTRING_PARAM_PATTERNS = [
     r'\s*:type\s+%s:\s*([^\n]+)',  # Sphinx
@@ -98,6 +99,15 @@ def _evaluate_for_statement_string(evaluator, string, module):
     """)
     if string is None:
         return []
+    
+    # MEVIS: if classes start with MLAB, look them up at special place.
+    if string.startswith("MLAB"):
+      string = "_PythonQt.private." + string
+
+    if string.startswith("ml::") and hasattr(settings, "AdvancedTypeLookup"):
+      type = settings.AdvancedTypeLookup.getWrapperClassName(string[4:])
+      if type:
+        string = type
 
     for element in re.findall('((?:\w+\.)*\w+)\.', string):
         # Try to import module part in dotted name.
diff --git i/jedi/evaluate/imports.py w/jedi/evaluate/imports.py
index 1d7c493..b9cae37 100644
--- i/jedi/evaluate/imports.py
+++ w/jedi/evaluate/imports.py
@@ -417,6 +417,13 @@ class _Importer(object):
                 sys.path, temp = sys_path, sys.path
                 try:
                     importing = find_module(string)
+                #MEVIS: support for builtin modules like "mevis"
+                except Exception:
+                    if string in sys.modules:
+                      importing = [None, string, False]
+                    else:
+                      raise
+                #MEVIS end
                 finally:
                     sys.path = temp
 
@@ -522,7 +529,7 @@ def _load_module(path=None, source=None, name=None, sys_path=None):
         p = fast.FastParser(common.source_to_unicode(source), p)
         cache.save_parser(path, name, p)
         return p.module
-
+        
     cached = cache.load_parser(path, name)
     return load(source) if cached is None else cached.module
 
diff --git i/jedi/evaluate/representation.py w/jedi/evaluate/representation.py
index 74ffcda..985e5f3 100644
--- i/jedi/evaluate/representation.py
+++ w/jedi/evaluate/representation.py
@@ -345,7 +345,8 @@ class Function(use_metaclass(CachedMetaClass, pr.IsScope)):
         f = self.base_func
 
         # Only enter it, if has not already been processed.
-        if not self.is_decorated:
+        # MEVIS patch: we don't want to resolve decorators, so that goto definition works
+        if False and not self.is_decorated:
             for dec in reversed(self.base_func.decorators):
                 debug.dbg('decorator: %s %s', dec, f)
                 dec_results = self._evaluator.eval_statement(dec)
diff --git i/jedi/settings.py w/jedi/settings.py
index 0daa3fa..e4a3c1b 100644
--- i/jedi/settings.py
+++ w/jedi/settings.py
@@ -148,23 +148,23 @@ function is being reparsed.
 # dynamic stuff
 # ----------------
 
-dynamic_arrays_instances = True
+dynamic_arrays_instances = False
 """
 Check for `append`, etc. on array instances like list()
 """
 
-dynamic_array_additions = True
+dynamic_array_additions = False
 """
 check for `append`, etc. on arrays: [], {}, ()
 """
 
-dynamic_params = True
+dynamic_params = False
 """
 A dynamic param completion, finds the callees of the function, which define
 the params of a function.
 """
 
-dynamic_params_for_other_modules = True
+dynamic_params_for_other_modules = False
 """
 Do the same for other modules.
 """
@@ -175,7 +175,7 @@ Additional modules in which |jedi| checks if statements are to be found. This
 is practical for IDEs, that want to administrate their modules themselves.
 """
 
-dynamic_flow_information = True
+dynamic_flow_information = False
 """
 Check for `isinstance` and other information to infer a type.
 """
@@ -193,7 +193,7 @@ This improves autocompletion for libraries that use ``setattr`` or
 # recursions
 # ----------------
 
-max_until_execution_unique = 50
+max_until_execution_unique = 0
 """
 This limit is probably the most important one, because if this limit is
 exceeded, functions can only be one time executed. So new functions will be
@@ -201,7 +201,7 @@ executed, complex recursions with the same functions again and again, are
 ignored.
 """
 
-max_function_recursion_level = 5
+max_function_recursion_level = 0
 """
 `max_function_recursion_level` is more about whether the recursions are
 stopped in deepth or in width. The ratio beetween this and
@@ -210,12 +210,12 @@ the number of function calls in the recursion), if it was already used
 earlier.
 """
 
-max_executions_without_builtins = 200
+max_executions_without_builtins = 0
 """
 .. todo:: Document this.
 """
 
-max_executions = 250
+max_executions = 0
 """
 A maximum amount of time, the completion may use.
 """
