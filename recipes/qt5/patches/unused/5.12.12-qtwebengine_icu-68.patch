diff --git i/qtwebengine/src/3rdparty/chromium/base/i18n/string_compare.cc w/qtwebengine/src/3rdparty/chromium/base/i18n/string_compare.cc
index 649c28119f..10ddcc20b8 100644
--- i/qtwebengine/src/3rdparty/chromium/base/i18n/string_compare.cc
+++ w/qtwebengine/src/3rdparty/chromium/base/i18n/string_compare.cc
@@ -18,8 +18,8 @@ UCollationResult CompareString16WithCollator(const icu::Collator& collator,
                                              const string16& rhs) {
   UErrorCode error = U_ZERO_ERROR;
   UCollationResult result = collator.compare(
-      icu::UnicodeString(FALSE, lhs.c_str(), static_cast<int>(lhs.length())),
-      icu::UnicodeString(FALSE, rhs.c_str(), static_cast<int>(rhs.length())),
+      icu::UnicodeString(false, lhs.c_str(), static_cast<int>(lhs.length())),
+      icu::UnicodeString(false, rhs.c_str(), static_cast<int>(rhs.length())),
       error);
   DCHECK(U_SUCCESS(error));
   return result;
diff --git i/qtwebengine/src/3rdparty/chromium/base/i18n/time_formatting.cc w/qtwebengine/src/3rdparty/chromium/base/i18n/time_formatting.cc
index 3a5394ae3a..b92a8bb243 100644
--- i/qtwebengine/src/3rdparty/chromium/base/i18n/time_formatting.cc
+++ w/qtwebengine/src/3rdparty/chromium/base/i18n/time_formatting.cc
@@ -237,7 +237,7 @@ bool TimeDurationFormatWithSeconds(const TimeDelta time,
   icu::FieldPosition ignore(icu::FieldPosition::DONT_CARE);
   measure_format.formatMeasures(measures, 3, formatted, ignore, status);
   *out = i18n::UnicodeStringToString16(formatted);
-  return U_SUCCESS(status) == TRUE;
+  return U_SUCCESS(status) == true;
 }
 
 string16 DateIntervalFormat(const Time& begin_time,
diff --git i/qtwebengine/src/3rdparty/chromium/components/autofill/core/common/autofill_regexes.cc w/qtwebengine/src/3rdparty/chromium/components/autofill/core/common/autofill_regexes.cc
index 3c289e3430..93db05989e 100644
--- i/qtwebengine/src/3rdparty/chromium/components/autofill/core/common/autofill_regexes.cc
+++ w/qtwebengine/src/3rdparty/chromium/components/autofill/core/common/autofill_regexes.cc
@@ -61,7 +61,7 @@ AutofillRegexes::~AutofillRegexes() {
 icu::RegexMatcher* AutofillRegexes::GetMatcher(const base::string16& pattern) {
   auto it = matchers_.find(pattern);
   if (it == matchers_.end()) {
-    const icu::UnicodeString icu_pattern(FALSE, pattern.data(),
+    const icu::UnicodeString icu_pattern(false, pattern.data(),
                                          pattern.length());
 
     UErrorCode status = U_ZERO_ERROR;
@@ -84,13 +84,13 @@ bool MatchesPattern(const base::string16& input,
                     const base::string16& pattern) {
   icu::RegexMatcher* matcher =
       AutofillRegexes::ThreadSpecificInstance()->GetMatcher(pattern);
-  icu::UnicodeString icu_input(FALSE, input.data(), input.length());
+  icu::UnicodeString icu_input(false, input.data(), input.length());
   matcher->reset(icu_input);
 
   UErrorCode status = U_ZERO_ERROR;
   UBool match = matcher->find(0, status);
   DCHECK(U_SUCCESS(status));
-  return match == TRUE;
+  return match == true;
 }
 
 }  // namespace autofill
diff --git i/qtwebengine/src/3rdparty/chromium/components/spellcheck/renderer/spellcheck_worditerator.cc w/qtwebengine/src/3rdparty/chromium/components/spellcheck/renderer/spellcheck_worditerator.cc
index 1bd631cbd8..7db38b8c4c 100644
--- i/qtwebengine/src/3rdparty/chromium/components/spellcheck/renderer/spellcheck_worditerator.cc
+++ w/qtwebengine/src/3rdparty/chromium/components/spellcheck/renderer/spellcheck_worditerator.cc
@@ -424,7 +424,7 @@ bool SpellcheckWordIterator::Normalize(int input_start,
   // spellchecker and we need manual normalization as well. The normalized
   // text does not have to be NUL-terminated since its characters are copied to
   // string16, which adds a NUL character when we need.
-  icu::UnicodeString input(FALSE, &text_[input_start], input_length);
+  icu::UnicodeString input(false, &text_[input_start], input_length);
   UErrorCode status = U_ZERO_ERROR;
   icu::UnicodeString output;
   icu::Normalizer::normalize(input, UNORM_NFKC, 0, output, status);
diff --git i/qtwebengine/src/3rdparty/chromium/components/url_formatter/idn_spoof_checker.cc w/qtwebengine/src/3rdparty/chromium/components/url_formatter/idn_spoof_checker.cc
index 83f54225a5..fee5aca4c2 100644
--- i/qtwebengine/src/3rdparty/chromium/components/url_formatter/idn_spoof_checker.cc
+++ w/qtwebengine/src/3rdparty/chromium/components/url_formatter/idn_spoof_checker.cc
@@ -332,7 +332,7 @@ bool IDNSpoofChecker::SafeToDisplayAsUnicode(
   if (U_FAILURE(status) || (result & USPOOF_ALL_CHECKS))
     return false;
 
-  icu::UnicodeString label_string(FALSE /* isTerminated */, label.data(),
+  icu::UnicodeString label_string(false /* isTerminated */, label.data(),
                                   base::checked_cast<int32_t>(label.size()));
 
   // A punycode label with 'xn--' prefix is not subject to the URL
@@ -453,7 +453,7 @@ bool IDNSpoofChecker::SafeToDisplayAsUnicode(
 
 bool IDNSpoofChecker::SimilarToTopDomains(base::StringPiece16 hostname) {
   size_t hostname_length = hostname.length() - (hostname.back() == '.' ? 1 : 0);
-  icu::UnicodeString host(FALSE, hostname.data(), hostname_length);
+  icu::UnicodeString host(false, hostname.data(), hostname_length);
   // If input has any characters outside Latin-Greek-Cyrillic and [0-9._-],
   // there is no point in getting rid of diacritics because combining marks
   // attached to non-LGC characters are already blocked.
@@ -610,7 +610,7 @@ bool IDNSpoofChecker::IsCyrillicTopLevelDomain(
     base::StringPiece tld,
     base::StringPiece16 tld_unicode) const {
   icu::UnicodeString tld_string(
-      FALSE /* isTerminated */, tld_unicode.data(),
+      false /* isTerminated */, tld_unicode.data(),
       base::checked_cast<int32_t>(tld_unicode.size()));
   if (cyrillic_letters_.containsSome(tld_string)) {
     return true;
diff --git i/qtwebengine/src/3rdparty/chromium/services/service_manager/zygote/zygote_linux.cc w/qtwebengine/src/3rdparty/chromium/services/service_manager/zygote/zygote_linux.cc
index 32528188e9..1c9c6d7fc3 100644
--- i/qtwebengine/src/3rdparty/chromium/services/service_manager/zygote/zygote_linux.cc
+++ w/qtwebengine/src/3rdparty/chromium/services/service_manager/zygote/zygote_linux.cc
@@ -571,7 +571,7 @@ base::ProcessId Zygote::ReadArgsAndFork(base::PickleIterator iter,
   if (!iter.ReadString16(&timezone_id))
     return -1;
   icu::TimeZone::adoptDefault(icu::TimeZone::createTimeZone(
-      icu::UnicodeString(FALSE, timezone_id.data(), timezone_id.length())));
+      icu::UnicodeString(false, timezone_id.data(), timezone_id.length())));
 
   if (!iter.ReadInt(&numfds))
     return -1;
diff --git i/qtwebengine/src/3rdparty/chromium/third_party/blink/renderer/platform/text/locale_icu.cc w/qtwebengine/src/3rdparty/chromium/third_party/blink/renderer/platform/text/locale_icu.cc
index 13c08e0ec8..c79ce0732c 100644
--- i/qtwebengine/src/3rdparty/chromium/third_party/blink/renderer/platform/text/locale_icu.cc
+++ w/qtwebengine/src/3rdparty/chromium/third_party/blink/renderer/platform/text/locale_icu.cc
@@ -170,12 +170,12 @@ static String GetDateFormatPattern(const UDateFormat* date_format) {
     return g_empty_string;
 
   UErrorCode status = U_ZERO_ERROR;
-  int32_t length = udat_toPattern(date_format, TRUE, nullptr, 0, &status);
+  int32_t length = udat_toPattern(date_format, true, nullptr, 0, &status);
   if (status != U_BUFFER_OVERFLOW_ERROR || !length)
     return g_empty_string;
   StringBuffer<UChar> buffer(length);
   status = U_ZERO_ERROR;
-  udat_toPattern(date_format, TRUE, buffer.Characters(), length, &status);
+  udat_toPattern(date_format, true, buffer.Characters(), length, &status);
   if (U_FAILURE(status))
     return g_empty_string;
   return String::Adopt(buffer);
diff --git i/qtwebengine/src/3rdparty/chromium/third_party/blink/renderer/platform/text/text_break_iterator_icu.cc w/qtwebengine/src/3rdparty/chromium/third_party/blink/renderer/platform/text/text_break_iterator_icu.cc
index 327c6f9a9e..ef6132baa2 100644
--- i/qtwebengine/src/3rdparty/chromium/third_party/blink/renderer/platform/text/text_break_iterator_icu.cc
+++ w/qtwebengine/src/3rdparty/chromium/third_party/blink/renderer/platform/text/text_break_iterator_icu.cc
@@ -315,13 +315,13 @@ static inline bool TextInChunkOrOutOfRange(UText* text,
       text->chunkOffset = offset <= std::numeric_limits<int32_t>::max()
                               ? static_cast<int32_t>(offset)
                               : 0;
-      is_accessible = TRUE;
+      is_accessible = true;
       return true;
     }
     if (native_index >= native_length &&
         text->chunkNativeLimit == native_length) {
       text->chunkOffset = text->chunkLength;
-      is_accessible = FALSE;
+      is_accessible = false;
       return true;
     }
   } else {
@@ -334,12 +334,12 @@ static inline bool TextInChunkOrOutOfRange(UText* text,
       text->chunkOffset = offset <= std::numeric_limits<int32_t>::max()
                               ? static_cast<int32_t>(offset)
                               : 0;
-      is_accessible = TRUE;
+      is_accessible = true;
       return true;
     }
     if (native_index <= 0 && !text->chunkNativeStart) {
       text->chunkOffset = 0;
-      is_accessible = FALSE;
+      is_accessible = false;
       return true;
     }
   }
@@ -350,7 +350,7 @@ static UBool TextLatin1Access(UText* text,
                               int64_t native_index,
                               UBool forward) {
   if (!text->context)
-    return FALSE;
+    return false;
   int64_t native_length = TextNativeLength(text);
   UBool is_accessible;
   if (TextInChunkOrOutOfRange(text, native_index, native_length, forward,
@@ -374,7 +374,7 @@ static UBool TextLatin1Access(UText* text,
     DCHECK_EQ(new_context, kPriorContext);
     TextLatin1SwitchToPriorContext(text, native_index, native_length, forward);
   }
-  return TRUE;
+  return true;
 }
 
 static const struct UTextFuncs kTextLatin1Funcs = {
@@ -514,7 +514,7 @@ static void TextUTF16SwitchToPriorContext(UText* text,
 
 static UBool TextUTF16Access(UText* text, int64_t native_index, UBool forward) {
   if (!text->context)
-    return FALSE;
+    return false;
   int64_t native_length = TextNativeLength(text);
   UBool is_accessible;
   if (TextInChunkOrOutOfRange(text, native_index, native_length, forward,
@@ -536,7 +536,7 @@ static UBool TextUTF16Access(UText* text, int64_t native_index, UBool forward) {
     DCHECK_EQ(new_context, kPriorContext);
     TextUTF16SwitchToPriorContext(text, native_index, native_length, forward);
   }
-  return TRUE;
+  return true;
 }
 
 static const struct UTextFuncs kTextUTF16Funcs = {
diff --git i/qtwebengine/src/3rdparty/chromium/third_party/blink/renderer/platform/text/unicode_utilities.cc w/qtwebengine/src/3rdparty/chromium/third_party/blink/renderer/platform/text/unicode_utilities.cc
index 0fbdb1784c..8a64f63321 100644
--- i/qtwebengine/src/3rdparty/chromium/third_party/blink/renderer/platform/text/unicode_utilities.cc
+++ w/qtwebengine/src/3rdparty/chromium/third_party/blink/renderer/platform/text/unicode_utilities.cc
@@ -300,7 +300,7 @@ void NormalizeCharactersIntoNFCForm(const UChar* characters,
   DCHECK(U_SUCCESS(status));
   int32_t input_length = static_cast<int32_t>(length);
   // copy-on-write.
-  icu::UnicodeString normalized(FALSE, characters, input_length);
+  icu::UnicodeString normalized(false, characters, input_length);
   // In the vast majority of cases, input is already NFC. Run a quick check
   // to avoid normalizing the entire input unnecessarily.
   int32_t normalized_prefix_length =
diff --git i/qtwebengine/src/3rdparty/chromium/third_party/blink/renderer/platform/wtf/text/text_codec_icu.cc w/qtwebengine/src/3rdparty/chromium/third_party/blink/renderer/platform/wtf/text/text_codec_icu.cc
index 5b933744c0..e3c286c43b 100644
--- i/qtwebengine/src/3rdparty/chromium/third_party/blink/renderer/platform/wtf/text/text_codec_icu.cc
+++ w/qtwebengine/src/3rdparty/chromium/third_party/blink/renderer/platform/wtf/text/text_codec_icu.cc
@@ -328,7 +328,7 @@ void TextCodecICU::CreateICUConverter() const {
   DLOG_IF(ERROR, err == U_AMBIGUOUS_ALIAS_WARNING)
       << "ICU ambiguous alias warning for encoding: " << encoding_.GetName();
   if (converter_icu_)
-    ucnv_setFallback(converter_icu_, TRUE);
+    ucnv_setFallback(converter_icu_, true);
 }
 
 int TextCodecICU::DecodeToBuffer(UChar* target,
diff --git i/qtwebengine/src/3rdparty/chromium/ui/base/l10n/formatter.cc w/qtwebengine/src/3rdparty/chromium/ui/base/l10n/formatter.cc
index 486a3a029c..d7a4172462 100644
--- i/qtwebengine/src/3rdparty/chromium/ui/base/l10n/formatter.cc
+++ w/qtwebengine/src/3rdparty/chromium/ui/base/l10n/formatter.cc
@@ -232,7 +232,7 @@ void Formatter::Format(Unit unit,
                        int value,
                        icu::UnicodeString* formatted_string) const {
   DCHECK(simple_format_[unit]);
-  DCHECK(formatted_string->isEmpty() == TRUE);
+  DCHECK(formatted_string->isEmpty() == true);
   UErrorCode error = U_ZERO_ERROR;
   FormatNumberInPlural(*simple_format_[unit],
                         value, formatted_string, &error);
@@ -248,7 +248,7 @@ void Formatter::Format(TwoUnits units,
       << "Detailed() not implemented for your (format, length) combination!";
   DCHECK(detailed_format_[units][1])
       << "Detailed() not implemented for your (format, length) combination!";
-  DCHECK(formatted_string->isEmpty() == TRUE);
+  DCHECK(formatted_string->isEmpty() == true);
   UErrorCode error = U_ZERO_ERROR;
   FormatNumberInPlural(*detailed_format_[units][0], value_1,
                        formatted_string, &error);
@@ -281,7 +281,7 @@ std::unique_ptr<icu::MessageFormat> Formatter::InitFormat(
     base::string16 pattern = l10n_util::GetStringUTF16(pluralities.id);
     UErrorCode error = U_ZERO_ERROR;
     std::unique_ptr<icu::MessageFormat> format(new icu::MessageFormat(
-        icu::UnicodeString(FALSE, pattern.data(), pattern.length()), error));
+        icu::UnicodeString(false, pattern.data(), pattern.length()), error));
     DCHECK(U_SUCCESS(error));
     if (format.get())
       return format;
diff --git i/qtwebengine/src/3rdparty/chromium/v8/src/objects/intl-objects.cc w/qtwebengine/src/3rdparty/chromium/v8/src/objects/intl-objects.cc
index 67f691a336..aafd868968 100644
--- i/qtwebengine/src/3rdparty/chromium/v8/src/objects/intl-objects.cc
+++ w/qtwebengine/src/3rdparty/chromium/v8/src/objects/intl-objects.cc
@@ -246,7 +246,7 @@ void SetResolvedDateSettings(Isolate* isolate, const icu::Locale& icu_locale,
   char result[ULOC_FULLNAME_CAPACITY];
   status = U_ZERO_ERROR;
   uloc_toLanguageTag(icu_locale.getName(), result, ULOC_FULLNAME_CAPACITY,
-                     FALSE, &status);
+                     false, &status);
   if (U_SUCCESS(status)) {
     JSObject::SetProperty(
         isolate, resolved, factory->NewStringFromStaticChars("locale"),
@@ -430,7 +430,7 @@ void SetResolvedNumericSettings(Isolate* isolate, const icu::Locale& icu_locale,
   char result[ULOC_FULLNAME_CAPACITY];
   UErrorCode status = U_ZERO_ERROR;
   uloc_toLanguageTag(icu_locale.getName(), result, ULOC_FULLNAME_CAPACITY,
-                     FALSE, &status);
+                     false, &status);
   if (U_SUCCESS(status)) {
     JSObject::SetProperty(
         isolate, resolved, factory->NewStringFromStaticChars("locale"),
@@ -665,7 +665,7 @@ void SetResolvedCollatorSettings(Isolate* isolate,
   char result[ULOC_FULLNAME_CAPACITY];
   status = U_ZERO_ERROR;
   uloc_toLanguageTag(icu_locale.getName(), result, ULOC_FULLNAME_CAPACITY,
-                     FALSE, &status);
+                     false, &status);
   if (U_SUCCESS(status)) {
     JSObject::SetProperty(
         isolate, resolved, factory->NewStringFromStaticChars("locale"),
@@ -805,7 +805,7 @@ void SetResolvedBreakIteratorSettings(Isolate* isolate,
   char result[ULOC_FULLNAME_CAPACITY];
   status = U_ZERO_ERROR;
   uloc_toLanguageTag(icu_locale.getName(), result, ULOC_FULLNAME_CAPACITY,
-                     FALSE, &status);
+                     false, &status);
   if (U_SUCCESS(status)) {
     JSObject::SetProperty(
         isolate, resolved, factory->NewStringFromStaticChars("locale"),
@@ -1180,7 +1180,7 @@ std::set<std::string> Intl::GetAvailableLocales(const IcuService& service) {
 
     error = U_ZERO_ERROR;
     // No need to force strict BCP47 rules.
-    uloc_toLanguageTag(icu_name, result, ULOC_FULLNAME_CAPACITY, FALSE, &error);
+    uloc_toLanguageTag(icu_name, result, ULOC_FULLNAME_CAPACITY, false, &error);
     if (U_FAILURE(error) || error == U_STRING_NOT_TERMINATED_WARNING) {
       // This shouldn't happen, but lets not break the user.
       continue;
diff --git i/qtwebengine/src/3rdparty/chromium/v8/src/runtime/runtime-intl.cc w/qtwebengine/src/3rdparty/chromium/v8/src/runtime/runtime-intl.cc
index 5d39074984..e18b2a85cc 100644
--- i/qtwebengine/src/3rdparty/chromium/v8/src/runtime/runtime-intl.cc
+++ w/qtwebengine/src/3rdparty/chromium/v8/src/runtime/runtime-intl.cc
@@ -86,7 +86,7 @@ RUNTIME_FUNCTION(Runtime_CanonicalizeLanguageTag) {
   char result[ULOC_FULLNAME_CAPACITY];
 
   // Force strict BCP47 rules.
-  uloc_toLanguageTag(icu_result, result, ULOC_FULLNAME_CAPACITY, TRUE, &error);
+  uloc_toLanguageTag(icu_result, result, ULOC_FULLNAME_CAPACITY, true, &error);
 
   if (U_FAILURE(error) || error == U_STRING_NOT_TERMINATED_WARNING) {
     return *factory->NewStringFromAsciiChecked(kInvalidTag);
@@ -138,7 +138,7 @@ RUNTIME_FUNCTION(Runtime_AvailableLocalesOf) {
 
     error = U_ZERO_ERROR;
     // No need to force strict BCP47 rules.
-    uloc_toLanguageTag(icu_name, result, ULOC_FULLNAME_CAPACITY, FALSE, &error);
+    uloc_toLanguageTag(icu_name, result, ULOC_FULLNAME_CAPACITY, false, &error);
     if (U_FAILURE(error) || error == U_STRING_NOT_TERMINATED_WARNING) {
       // This shouldn't happen, but lets not break the user.
       continue;
@@ -170,7 +170,7 @@ RUNTIME_FUNCTION(Runtime_GetDefaultICULocale) {
   char result[ULOC_FULLNAME_CAPACITY];
   UErrorCode status = U_ZERO_ERROR;
   uloc_toLanguageTag(default_locale.getName(), result, ULOC_FULLNAME_CAPACITY,
-                     FALSE, &status);
+                     false, &status);
   if (U_SUCCESS(status)) {
     return *factory->NewStringFromAsciiChecked(result);
   }
@@ -388,9 +388,9 @@ RUNTIME_FUNCTION(Runtime_InternalCompare) {
     std::unique_ptr<uc16[]> sap1;
     std::unique_ptr<uc16[]> sap2;
     icu::UnicodeString string_val1(
-        FALSE, GetUCharBufferFromFlat(flat1, &sap1, length1), length1);
+        false, GetUCharBufferFromFlat(flat1, &sap1, length1), length1);
     icu::UnicodeString string_val2(
-        FALSE, GetUCharBufferFromFlat(flat2, &sap2, length2), length2);
+        false, GetUCharBufferFromFlat(flat2, &sap2, length2), length2);
     result = collator->compare(string_val1, string_val2, status);
   }
   if (U_FAILURE(status)) return isolate->ThrowIllegalOperation();
