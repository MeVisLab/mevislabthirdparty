diff --git i/doc/examplecode.txt w/doc/examplecode.txt
index ad0bd98..6843e33 100644
--- i/doc/examplecode.txt
+++ w/doc/examplecode.txt
@@ -607,12 +607,12 @@ thread-safe counter.
 #include <openvdb/openvdb.h>
 #include <openvdb/tools/LevelSetSphere.h>
 #include <tbb/parallel_for.h>
-#include <tbb/atomic.h>
+#include <atomic>
 #include <cassert>
 #include <iostream>
 
 // Global active voxel counter, atomically updated from multiple threads
-tbb::atomic<openvdb::Index64> activeLeafVoxelCount;
+std::atomic<openvdb::Index64> activeLeafVoxelCount;
 
 // Functor for use with tbb::parallel_for() that operates on a grid's leaf nodes
 template<typename GridType>
@@ -632,7 +632,7 @@ struct LeafProcessor
             // Retrieve the leaf node to which the iterator is pointing.
             const LeafNode& leaf = *range.iterator();
             // Update the global counter.
-            activeLeafVoxelCount.fetch_and_add(leaf.onVoxelCount());
+            activeLeafVoxelCount.fetch_add(leaf.onVoxelCount());
         }
     }
 };
diff --git i/openvdb/openvdb/Grid.cc w/openvdb/openvdb/Grid.cc
index 45374ef..f416180 100644
--- i/openvdb/openvdb/Grid.cc
+++ w/openvdb/openvdb/Grid.cc
@@ -6,7 +6,7 @@
 #include <openvdb/Metadata.h>
 #include <boost/algorithm/string/case_conv.hpp>
 #include <boost/algorithm/string/trim.hpp>
-#include <tbb/mutex.h>
+#include <mutex>
 
 
 namespace openvdb {
@@ -38,12 +38,9 @@ namespace {
 using GridFactoryMap = std::map<Name, GridBase::GridFactory>;
 using GridFactoryMapCIter = GridFactoryMap::const_iterator;
 
-using Mutex = tbb::mutex;
-using Lock = Mutex::scoped_lock;
-
 struct LockedGridRegistry {
     LockedGridRegistry() {}
-    Mutex mMutex;
+    std::mutex mMutex;
     GridFactoryMap mMap;
 };
 
@@ -63,7 +60,7 @@ bool
 GridBase::isRegistered(const Name& name)
 {
     LockedGridRegistry* registry = getGridRegistry();
-    Lock lock(registry->mMutex);
+    std::lock_guard<std::mutex> lock(registry->mMutex);
 
     return (registry->mMap.find(name) != registry->mMap.end());
 }
@@ -73,7 +70,7 @@ void
 GridBase::registerGrid(const Name& name, GridFactory factory)
 {
     LockedGridRegistry* registry = getGridRegistry();
-    Lock lock(registry->mMutex);
+    std::lock_guard<std::mutex> lock(registry->mMutex);
 
     if (registry->mMap.find(name) != registry->mMap.end()) {
         OPENVDB_THROW(KeyError, "Grid type " << name << " is already registered");
@@ -87,7 +84,7 @@ void
 GridBase::unregisterGrid(const Name& name)
 {
     LockedGridRegistry* registry = getGridRegistry();
-    Lock lock(registry->mMutex);
+    std::lock_guard<std::mutex> lock(registry->mMutex);
 
     registry->mMap.erase(name);
 }
@@ -97,7 +94,7 @@ GridBase::Ptr
 GridBase::createGrid(const Name& name)
 {
     LockedGridRegistry* registry = getGridRegistry();
-    Lock lock(registry->mMutex);
+    std::lock_guard<std::mutex> lock(registry->mMutex);
 
     GridFactoryMapCIter iter = registry->mMap.find(name);
 
@@ -113,7 +110,7 @@ void
 GridBase::clearRegistry()
 {
     LockedGridRegistry* registry = getGridRegistry();
-    Lock lock(registry->mMutex);
+    std::lock_guard<std::mutex> lock(registry->mMutex);
 
     registry->mMap.clear();
 }
diff --git i/openvdb/openvdb/Grid.h w/openvdb/openvdb/Grid.h
index bc286b7..ffad0c4 100644
--- i/openvdb/openvdb/Grid.h
+++ w/openvdb/openvdb/Grid.h
@@ -978,14 +978,7 @@ public:
     /// Return @c true if this grid type is registered.
     static bool isRegistered() { return GridBase::isRegistered(Grid::gridType()); }
     /// Register this grid type along with a factory function.
-    static void registerGrid()
-    {
-        GridBase::registerGrid(Grid::gridType(), Grid::factory);
-        if (!tree::internal::LeafBufferFlags<ValueType>::IsAtomic) {
-            OPENVDB_LOG_WARN("delayed loading of grids of type " << Grid::gridType()
-                << " might not be threadsafe on this platform");
-        }
-    }
+    static void registerGrid() { GridBase::registerGrid(Grid::gridType(), Grid::factory); }
     /// Remove this grid type from the registry.
     static void unregisterGrid() { GridBase::unregisterGrid(Grid::gridType()); }
 
diff --git i/openvdb/openvdb/Metadata.cc w/openvdb/openvdb/Metadata.cc
index a2c8511..a68c4ef 100644
--- i/openvdb/openvdb/Metadata.cc
+++ w/openvdb/openvdb/Metadata.cc
@@ -3,9 +3,9 @@
 
 #include "Metadata.h"
 
-#include <tbb/mutex.h>
 #include <algorithm> // for std::min()
 #include <map>
+#include <mutex>
 #include <sstream>
 #include <vector>
 
@@ -14,9 +14,6 @@ namespace openvdb {
 OPENVDB_USE_VERSION_NAMESPACE
 namespace OPENVDB_VERSION_NAME {
 
-using Mutex = tbb::mutex;
-using Lock = Mutex::scoped_lock;
-
 using createMetadata = Metadata::Ptr (*)();
 using MetadataFactoryMap = std::map<Name, createMetadata>;
 using MetadataFactoryMapCIter = MetadataFactoryMap::const_iterator;
@@ -24,7 +21,7 @@ using MetadataFactoryMapCIter = MetadataFactoryMap::const_iterator;
 struct LockedMetadataTypeRegistry {
     LockedMetadataTypeRegistry() {}
     ~LockedMetadataTypeRegistry() {}
-    Mutex mMutex;
+    std::mutex mMutex;
     MetadataFactoryMap mMap;
 };
 
@@ -40,7 +37,7 @@ bool
 Metadata::isRegisteredType(const Name &typeName)
 {
     LockedMetadataTypeRegistry *registry = getMetadataTypeRegistry();
-    Lock lock(registry->mMutex);
+    std::lock_guard<std::mutex> lock(registry->mMutex);
 
     return (registry->mMap.find(typeName) != registry->mMap.end());
 }
@@ -49,7 +46,7 @@ void
 Metadata::registerType(const Name &typeName, Metadata::Ptr (*createMetadata)())
 {
     LockedMetadataTypeRegistry *registry = getMetadataTypeRegistry();
-    Lock lock(registry->mMutex);
+    std::lock_guard<std::mutex> lock(registry->mMutex);
 
     if (registry->mMap.find(typeName) != registry->mMap.end()) {
         OPENVDB_THROW(KeyError,
@@ -63,7 +60,7 @@ void
 Metadata::unregisterType(const Name &typeName)
 {
     LockedMetadataTypeRegistry *registry = getMetadataTypeRegistry();
-    Lock lock(registry->mMutex);
+    std::lock_guard<std::mutex> lock(registry->mMutex);
 
     registry->mMap.erase(typeName);
 }
@@ -72,7 +69,7 @@ Metadata::Ptr
 Metadata::createMetadata(const Name &typeName)
 {
     LockedMetadataTypeRegistry *registry = getMetadataTypeRegistry();
-    Lock lock(registry->mMutex);
+    std::lock_guard<std::mutex> lock(registry->mMutex);
 
     MetadataFactoryMapCIter iter = registry->mMap.find(typeName);
 
@@ -88,7 +85,7 @@ void
 Metadata::clearRegistry()
 {
     LockedMetadataTypeRegistry *registry = getMetadataTypeRegistry();
-    Lock lock(registry->mMutex);
+    std::lock_guard<std::mutex> lock(registry->mMutex);
 
     registry->mMap.clear();
 }
diff --git i/openvdb/openvdb/io/Archive.cc w/openvdb/openvdb/io/Archive.cc
index 1cf342b..f719f98 100644
--- i/openvdb/openvdb/io/Archive.cc
+++ w/openvdb/openvdb/io/Archive.cc
@@ -29,7 +29,7 @@
 #include <boost/uuid/uuid_generators.hpp>
 #include <boost/uuid/uuid_io.hpp>
 
-#include <tbb/atomic.h>
+#include <atomic>
 
 #ifdef _MSC_VER
 #include <boost/interprocess/detail/os_file_functions.hpp> // open_existing_file(), close_file()
@@ -514,7 +514,7 @@ public:
     boost::interprocess::mapped_region mRegion;
     bool mAutoDelete;
     Notifier mNotifier;
-    mutable tbb::atomic<Index64> mLastWriteTime;
+    mutable std::atomic<Index64> mLastWriteTime;
 
 private:
     Impl(const Impl&); // not copyable
diff --git i/openvdb/openvdb/io/Queue.cc w/openvdb/openvdb/io/Queue.cc
index 706fbf3..ef5d296 100644
--- i/openvdb/openvdb/io/Queue.cc
+++ w/openvdb/openvdb/io/Queue.cc
@@ -10,16 +10,15 @@
 #include "Stream.h"
 #include <openvdb/Exceptions.h>
 #include <openvdb/util/logging.h>
-#include <tbb/atomic.h>
 #include <tbb/concurrent_hash_map.h>
-#include <tbb/mutex.h>
 #include <tbb/task.h>
 #include <tbb/tbb_thread.h> // for tbb::this_tbb_thread::sleep()
 #include <tbb/tick_count.h>
 #include <algorithm> // for std::max()
+#include <atomic>
 #include <iostream>
 #include <map>
-
+#include <mutex>
 
 namespace openvdb {
 OPENVDB_USE_VERSION_NAMESPACE
@@ -28,10 +27,6 @@ namespace io {
 
 namespace {
 
-using Mutex = tbb::mutex;
-using Lock = Mutex::scoped_lock;
-
-
 // Abstract base class for queuable TBB tasks that adds a task completion callback
 class Task: public tbb::task
 {
@@ -139,7 +134,7 @@ struct Queue::Impl
             // invokes a notifier method such as removeNotifier() on this queue,
             // the result will be a deadlock.
             /// @todo Is it worth trying to avoid such deadlocks?
-            Lock lock(mNotifierMutex);
+            std::lock_guard<std::mutex> lock(mNotifierMutex);
             if (!mNotifiers.empty()) {
                 didNotify = true;
                 for (NotifierMap::const_iterator it = mNotifiers.begin();
@@ -184,12 +179,12 @@ struct Queue::Impl
 
     Index32 mTimeout;
     Index32 mCapacity;
-    tbb::atomic<Int32> mNumTasks;
+    std::atomic<Int32> mNumTasks;
     Index32 mNextId;
     StatusMap mStatus;
     NotifierMap mNotifiers;
     Index32 mNextNotifierId;
-    Mutex mNotifierMutex;
+    std::mutex mNotifierMutex;
 };
 
 
@@ -255,7 +250,7 @@ Queue::status(Id id) const
 Queue::Id
 Queue::addNotifier(Notifier notify)
 {
-    Lock lock(mImpl->mNotifierMutex);
+    std::lock_guard<std::mutex> lock(mImpl->mNotifierMutex);
     Queue::Id id = mImpl->mNextNotifierId++;
     mImpl->mNotifiers[id] = notify;
     return id;
@@ -265,7 +260,7 @@ Queue::addNotifier(Notifier notify)
 void
 Queue::removeNotifier(Id id)
 {
-    Lock lock(mImpl->mNotifierMutex);
+    std::lock_guard<std::mutex> lock(mImpl->mNotifierMutex);
     Impl::NotifierMap::iterator it = mImpl->mNotifiers.find(id);
     if (it != mImpl->mNotifiers.end()) {
         mImpl->mNotifiers.erase(it);
@@ -276,7 +271,7 @@ Queue::removeNotifier(Id id)
 void
 Queue::clearNotifiers()
 {
-    Lock lock(mImpl->mNotifierMutex);
+    std::lock_guard<std::mutex> lock(mImpl->mNotifierMutex);
     mImpl->mNotifiers.clear();
 }
 
diff --git i/openvdb/openvdb/math/Maps.cc w/openvdb/openvdb/math/Maps.cc
index 1512305..f6e4771 100644
--- i/openvdb/openvdb/math/Maps.cc
+++ w/openvdb/openvdb/math/Maps.cc
@@ -2,7 +2,7 @@
 // SPDX-License-Identifier: MPL-2.0
 
 #include "Maps.h"
-#include <tbb/mutex.h>
+#include <mutex>
 
 namespace openvdb {
 OPENVDB_USE_VERSION_NAMESPACE
@@ -11,13 +11,10 @@ namespace math {
 
 namespace {
 
-using Mutex = tbb::mutex;
-using Lock = Mutex::scoped_lock;
-
 // Declare this at file scope to ensure thread-safe initialization.
 // NOTE: Do *NOT* move this into Maps.h or else we will need to pull in
 //       Windows.h with things like 'rad2' defined!
-Mutex sInitMapRegistryMutex;
+std::mutex sInitMapRegistryMutex;
 
 } // unnamed namespace
 
@@ -37,7 +34,7 @@ MapRegistry::staticInstance()
 MapRegistry*
 MapRegistry::instance()
 {
-    Lock lock(sInitMapRegistryMutex);
+    std::lock_guard<std::mutex> lock(sInitMapRegistryMutex);
     return staticInstance();
 }
 
@@ -45,7 +42,7 @@ MapRegistry::instance()
 MapBase::Ptr
 MapRegistry::createMap(const Name& name)
 {
-    Lock lock(sInitMapRegistryMutex);
+    std::lock_guard<std::mutex> lock(sInitMapRegistryMutex);
     MapDictionary::const_iterator iter = staticInstance()->mMap.find(name);
 
     if (iter == staticInstance()->mMap.end()) {
@@ -59,7 +56,7 @@ MapRegistry::createMap(const Name& name)
 bool
 MapRegistry::isRegistered(const Name& name)
 {
-    Lock lock(sInitMapRegistryMutex);
+    std::lock_guard<std::mutex> lock(sInitMapRegistryMutex);
     return (staticInstance()->mMap.find(name) != staticInstance()->mMap.end());
 }
 
@@ -67,7 +64,7 @@ MapRegistry::isRegistered(const Name& name)
 void
 MapRegistry::registerMap(const Name& name, MapBase::MapFactory factory)
 {
-    Lock lock(sInitMapRegistryMutex);
+    std::lock_guard<std::mutex> lock(sInitMapRegistryMutex);
 
     if (staticInstance()->mMap.find(name) != staticInstance()->mMap.end()) {
         OPENVDB_THROW(KeyError, "Map type " << name << " is already registered");
@@ -80,7 +77,7 @@ MapRegistry::registerMap(const Name& name, MapBase::MapFactory factory)
 void
 MapRegistry::unregisterMap(const Name& name)
 {
-    Lock lock(sInitMapRegistryMutex);
+    std::lock_guard<std::mutex> lock(sInitMapRegistryMutex);
     staticInstance()->mMap.erase(name);
 }
 
@@ -88,7 +85,7 @@ MapRegistry::unregisterMap(const Name& name)
 void
 MapRegistry::clear()
 {
-    Lock lock(sInitMapRegistryMutex);
+    std::lock_guard<std::mutex> lock(sInitMapRegistryMutex);
     staticInstance()->mMap.clear();
 }
 
diff --git i/openvdb/openvdb/openvdb.cc w/openvdb/openvdb/openvdb.cc
index fe31693..439268f 100644
--- i/openvdb/openvdb/openvdb.cc
+++ w/openvdb/openvdb/openvdb.cc
@@ -35,19 +35,16 @@ namespace openvdb {
 OPENVDB_USE_VERSION_NAMESPACE
 namespace OPENVDB_VERSION_NAME {
 
-typedef tbb::mutex Mutex;
-typedef Mutex::scoped_lock Lock;
-
 namespace {
 // Declare this at file scope to ensure thread-safe initialization.
-Mutex sInitMutex;
+std::mutex sInitMutex;
 bool sIsInitialized = false;
 }
 
 void
 initialize()
 {
-    Lock lock(sInitMutex);
+    std::lock_guard<std::mutex> lock(sInitMutex);
     if (sIsInitialized) return;
 
     logging::initialize();
@@ -134,7 +131,7 @@ __pragma(warning(default:1711))
 void
 uninitialize()
 {
-    Lock lock(sInitMutex);
+    std::lock_guard<std::mutex> lock(sInitMutex);
 
 #ifdef __ICC
 // Disable ICC "assignment to statically allocated variable" warning.
diff --git i/openvdb/openvdb/points/AttributeArray.cc w/openvdb/openvdb/points/AttributeArray.cc
index 67d0ca7..70f92f8 100644
--- i/openvdb/openvdb/points/AttributeArray.cc
+++ w/openvdb/openvdb/points/AttributeArray.cc
@@ -67,7 +67,7 @@ AttributeArray::AttributeArray(const AttributeArray& rhs)
     : mIsUniform(rhs.mIsUniform)
     , mFlags(rhs.mFlags)
     , mUsePagedRead(rhs.mUsePagedRead)
-    , mOutOfCore(rhs.mOutOfCore)
+    , mOutOfCore(rhs.mOutOfCore.load())
     , mPageHandle()
 {
     if (mFlags & PARTIALREAD)       mCompressedBytes = rhs.mCompressedBytes;
@@ -84,7 +84,7 @@ AttributeArray::operator=(const AttributeArray& rhs)
     mIsUniform = rhs.mIsUniform;
     mFlags = rhs.mFlags;
     mUsePagedRead = rhs.mUsePagedRead;
-    mOutOfCore = rhs.mOutOfCore;
+    mOutOfCore.store(rhs.mOutOfCore);
     if (mFlags & PARTIALREAD)       mCompressedBytes = rhs.mCompressedBytes;
     else if (rhs.mPageHandle)       mPageHandle = rhs.mPageHandle->copy();
     else                            mPageHandle.reset();
diff --git i/openvdb/openvdb/points/AttributeArray.h w/openvdb/openvdb/points/AttributeArray.h
index d6dcdaa..768a4a5 100644
--- i/openvdb/openvdb/points/AttributeArray.h
+++ w/openvdb/openvdb/points/AttributeArray.h
@@ -21,7 +21,7 @@
 #include "StreamCompression.h"
 
 #include <tbb/spin_mutex.h>
-#include <tbb/atomic.h>
+#include <atomic>
 
 #include <memory>
 #include <mutex>
@@ -407,7 +407,7 @@ protected:
     mutable tbb::spin_mutex mMutex;
     uint8_t mFlags = 0;
     uint8_t mUsePagedRead = 0;
-    tbb::atomic<Index32> mOutOfCore; // interpreted as bool
+    std::atomic<Index32> mOutOfCore; // interpreted as bool
     /// used for out-of-core, paged reading
     union {
         compression::PageHandle::Ptr mPageHandle;
diff --git i/openvdb/openvdb/python/pyutil.h w/openvdb/openvdb/python/pyutil.h
index 4fd6396..2bf6ec4 100644
--- i/openvdb/openvdb/python/pyutil.h
+++ w/openvdb/openvdb/python/pyutil.h
@@ -7,10 +7,10 @@
 #include "openvdb/openvdb.h"
 #include "openvdb/points/PointDataGrid.h"
 #include <boost/python.hpp>
-#include <tbb/mutex.h>
-#include <map> // for std::pair
-#include <string>
+#include <mutex>
 #include <sstream>
+#include <string>
+#include <utility> // for std::pair
 
 
 namespace pyutil {
@@ -129,12 +129,12 @@ struct StringEnum
     /// Return the (key, value) map as a Python dict.
     static boost::python::dict items()
     {
-        static tbb::mutex sMutex;
+        static std::mutex sMutex;
         static boost::python::dict itemDict;
         if (!itemDict) {
             // The first time this function is called, populate
             // the static dict with (key, value) pairs.
-            tbb::mutex::scoped_lock lock(sMutex);
+            std::lock_guard<std::mutex> lock(sMutex);
             if (!itemDict) {
                 for (int i = 0; ; ++i) {
                     const CStringPair item = Descr::item(i);
diff --git i/openvdb/openvdb/tools/FastSweeping.h w/openvdb/openvdb/tools/FastSweeping.h
index 03fab13..7983dac 100644
--- i/openvdb/openvdb/tools/FastSweeping.h
+++ w/openvdb/openvdb/tools/FastSweeping.h
@@ -574,7 +574,7 @@ void FastSweeping<SdfGridT, ExtValueT>::computeSweepMaskLeafOrigins()
     LeafManagerT leafManager(mSweepMask);
 
     mSweepMaskLeafOrigins.resize(leafManager.leafCount());
-    tbb::atomic<size_t> sweepingVoxelCount = 0;
+    std::atomic<size_t> sweepingVoxelCount{0};
     auto kernel = [&](const LeafT& leaf, size_t leafIdx) {
         mSweepMaskLeafOrigins[leafIdx] = leaf.origin();
         sweepingVoxelCount += leaf.onVoxelCount();
diff --git i/openvdb/openvdb/tools/PointIndexGrid.h w/openvdb/openvdb/tools/PointIndexGrid.h
index a2e2a7c..e9ebf96 100644
--- i/openvdb/openvdb/tools/PointIndexGrid.h
+++ w/openvdb/openvdb/tools/PointIndexGrid.h
@@ -27,9 +27,9 @@
 #include <openvdb/tree/LeafNode.h>
 #include <openvdb/tree/Tree.h>
 
-#include <tbb/atomic.h>
 #include <tbb/blocked_range.h>
 #include <tbb/parallel_for.h>
+#include <atomic>
 #include <algorithm> // for std::min(), std::max()
 #include <cmath> // for std::sqrt()
 #include <deque>
@@ -343,7 +343,7 @@ namespace point_index_grid_internal {
 template<typename PointArrayT>
 struct ValidPartitioningOp
 {
-    ValidPartitioningOp(tbb::atomic<bool>& hasChanged,
+    ValidPartitioningOp(std::atomic<bool>& hasChanged,
         const PointArrayT& points, const math::Transform& xform)
         : mPoints(&points)
         , mTransform(&xform)
@@ -382,7 +382,7 @@ struct ValidPartitioningOp
 
                 mPoints->getPos(*begin, point);
                 if (voxelCoord != mTransform->worldToIndexCellCentered(point)) {
-                    mHasChanged->fetch_and_store(true);
+                    mHasChanged->store(true);
                     break;
                 }
 
@@ -394,7 +394,7 @@ struct ValidPartitioningOp
 private:
     PointArrayT         const * const mPoints;
     math::Transform     const * const mTransform;
-    tbb::atomic<bool>         * const mHasChanged;
+    std::atomic<bool>         * const mHasChanged;
 };
 
 
@@ -1311,7 +1311,7 @@ isValidPartition(const PointArrayT& points, const GridT& grid)
         return false;
     }
 
-    tbb::atomic<bool> changed;
+    std::atomic<bool> changed;
     changed = false;
 
     point_index_grid_internal::ValidPartitioningOp<PointArrayT>
diff --git i/openvdb/openvdb/tree/LeafBuffer.h w/openvdb/openvdb/tree/LeafBuffer.h
index 5366bc0..2901e13 100644
--- i/openvdb/openvdb/tree/LeafBuffer.h
+++ w/openvdb/openvdb/tree/LeafBuffer.h
@@ -7,9 +7,9 @@
 #include <openvdb/Types.h>
 #include <openvdb/io/Compression.h> // for io::readCompressedValues(), etc
 #include <openvdb/util/NodeMasks.h>
-#include <tbb/atomic.h>
 #include <tbb/spin_mutex.h>
 #include <algorithm> // for std::swap
+#include <atomic>
 #include <cstddef> // for offsetof()
 #include <iostream>
 #include <memory>
@@ -23,29 +23,6 @@ OPENVDB_USE_VERSION_NAMESPACE
 namespace OPENVDB_VERSION_NAME {
 namespace tree {
 
-namespace internal {
-
-/// @internal For delayed loading to be threadsafe, LeafBuffer::mOutOfCore must be
-/// memory-fenced when it is set in LeafBuffer::doLoad(), otherwise that operation
-/// could be reordered ahead of others in doLoad(), with the possible result that
-/// other threads could see the buffer as in-core before it has been fully loaded.
-/// Making mOutOfCore a TBB atomic solves the problem, since TBB atomics are release-fenced
-/// by default (unlike STL atomics, which are not even guaranteed to be lock-free).
-/// However, TBB atomics have stricter alignment requirements than their underlying value_types,
-/// so a LeafBuffer with an atomic mOutOfCore is potentially ABI-incompatible with
-/// its non-atomic counterpart.
-/// This helper class conditionally declares mOutOfCore as an atomic only if doing so
-/// doesn't break ABI compatibility.
-template<typename T>
-struct LeafBufferFlags
-{
-    /// The type of LeafBuffer::mOutOfCore
-    using type = tbb::atomic<Index32>;
-    static constexpr bool IsAtomic = true;
-};
-
-} // namespace internal
-
 
 /// @brief Array of fixed size 2<SUP>3<I>Log2Dim</I></SUP> that stores
 /// the voxel values of a LeafNode
@@ -142,7 +119,7 @@ private:
     inline void doLoad() const;
     inline bool detachFromFile();
 
-    using FlagsType = typename internal::LeafBufferFlags<ValueType>::type;
+    using FlagsType = std::atomic<Index32>;
 
     union {
         ValueType* mData;
@@ -193,7 +170,7 @@ template<typename T, Index Log2Dim>
 inline
 LeafBuffer<T, Log2Dim>::LeafBuffer(const LeafBuffer& other)
     : mData(nullptr)
-    , mOutOfCore(other.mOutOfCore)
+    , mOutOfCore(other.mOutOfCore.load())
 {
     if (other.isOutOfCore()) {
         mFileInfo = new FileInfo(*other.mFileInfo);
@@ -228,7 +205,8 @@ LeafBuffer<T, Log2Dim>::operator=(const LeafBuffer& other)
             if (other.isOutOfCore()) this->deallocate();
         }
         if (other.isOutOfCore()) {
-            mOutOfCore = other.mOutOfCore;
+            mOutOfCore.store(other.mOutOfCore.load(std::memory_order_acquire),
+                             std::memory_order_release);
             mFileInfo = new FileInfo(*other.mFileInfo);
         } else if (other.mData != nullptr) {
             this->allocate();
@@ -275,7 +253,14 @@ inline void
 LeafBuffer<T, Log2Dim>::swap(LeafBuffer& other)
 {
     std::swap(mData, other.mData);
-    std::swap(mOutOfCore, other.mOutOfCore);
+
+    // Two atomics can't be swapped because it would require hardware support:
+    // https://en.wikipedia.org/wiki/Double_compare-and-swap
+    // Note that there's a window in which other.mOutOfCore could be written
+    // between our load from it and our store to it.
+    auto tmp = other.mOutOfCore.load(std::memory_order_acquire);
+    tmp = mOutOfCore.exchange(std::move(tmp));
+    other.mOutOfCore.store(std::move(tmp), std::memory_order_release);
 }
 
 
diff --git i/openvdb/openvdb/unittest/TestAttributeArray.cc w/openvdb/openvdb/unittest/TestAttributeArray.cc
index bf67dba..d8d6341 100644
--- i/openvdb/openvdb/unittest/TestAttributeArray.cc
+++ w/openvdb/openvdb/unittest/TestAttributeArray.cc
@@ -20,8 +20,8 @@
 #include <boost/interprocess/file_mapping.hpp>
 #include <boost/interprocess/mapped_region.hpp>
 #include <tbb/tick_count.h>
-#include <tbb/atomic.h>
 
+#include <atomic>
 #include <cstdio> // for std::remove()
 #include <fstream>
 #include <sstream>
diff --git i/openvdb/openvdb/unittest/TestPointMove.cc w/openvdb/openvdb/unittest/TestPointMove.cc
index 46f87a3..348a659 100644
--- i/openvdb/openvdb/unittest/TestPointMove.cc
+++ w/openvdb/openvdb/unittest/TestPointMove.cc
@@ -10,8 +10,8 @@
 #include <openvdb/points/PointScatter.h>
 #include <openvdb/openvdb.h>
 #include <openvdb/Types.h>
-#include <tbb/atomic.h>
 #include <algorithm>
+#include <atomic>
 #include <map>
 #include <sstream>
 #include <string>
@@ -687,8 +687,8 @@ struct CustomDeformer
     using LeafT = PointDataGrid::TreeType::LeafNodeType;
 
     CustomDeformer(const openvdb::Vec3d& offset,
-                   tbb::atomic<int>& resetCalls,
-                   tbb::atomic<int>& applyCalls)
+                   std::atomic<int>& resetCalls,
+                   std::atomic<int>& applyCalls)
         : mOffset(offset)
         , mResetCalls(resetCalls)
         , mApplyCalls(applyCalls) { }
@@ -710,8 +710,8 @@ struct CustomDeformer
     }
 
     const openvdb::Vec3d mOffset;
-    tbb::atomic<int>& mResetCalls;
-    tbb::atomic<int>& mApplyCalls;
+    std::atomic<int>& mResetCalls;
+    std::atomic<int>& mApplyCalls;
 }; // struct CustomDeformer
 
 // Custom Deformer that always returns the position supplied in the constructor
@@ -755,7 +755,7 @@ TEST_F(TestPointMove, testCustomDeformer)
         const int leafCount = points->tree().leafCount();
         const int pointCount = int(positions.size());
 
-        tbb::atomic<int> resetCalls, applyCalls;
+        std::atomic<int> resetCalls, applyCalls;
         resetCalls = 0;
         applyCalls = 0;
 
diff --git i/openvdb/openvdb/unittest/TestStreamCompression.cc w/openvdb/openvdb/unittest/TestStreamCompression.cc
index 107dbd7..40f98d9 100644
--- i/openvdb/openvdb/unittest/TestStreamCompression.cc
+++ w/openvdb/openvdb/unittest/TestStreamCompression.cc
@@ -24,8 +24,6 @@
 #include <boost/uuid/uuid_io.hpp>
 #include <boost/version.hpp> // for BOOST_VERSION
 
-#include <tbb/atomic.h>
-
 #ifdef _MSC_VER
 #include <boost/interprocess/detail/os_file_functions.hpp> // open_existing_file(), close_file()
 // boost::interprocess::detail was renamed to boost::interprocess::ipcdetail in Boost 1.48.
@@ -38,6 +36,7 @@ namespace boost { namespace interprocess { namespace detail {} namespace ipcdeta
 #include <unistd.h> // for unlink()
 #endif
 
+#include <atomic>
 #include <fstream>
 #include <numeric> // for std::iota()
 
@@ -97,7 +96,7 @@ private:
         boost::interprocess::mapped_region mRegion;
         bool mAutoDelete = false;
         Notifier mNotifier;
-        mutable tbb::atomic<openvdb::Index64> mLastWriteTime;
+        mutable std::atomic<openvdb::Index64> mLastWriteTime;
     }; // class Impl
     std::unique_ptr<Impl> mImpl;
 }; // class ProxyMappedFile
diff --git i/openvdb/openvdb/unittest/TestTools.cc w/openvdb/openvdb/unittest/TestTools.cc
index 0fd46dd..859598a 100644
--- i/openvdb/openvdb/unittest/TestTools.cc
+++ w/openvdb/openvdb/unittest/TestTools.cc
@@ -28,8 +28,8 @@
 #include <openvdb/math/Stats.h>
 #include "util.h" // for unittest_util::makeSphere()
 #include "gtest/gtest.h"
-#include <tbb/atomic.h>
 #include <algorithm> // for std::sort
+#include <atomic>
 #include <random>
 #include <sstream>
 
@@ -2544,21 +2544,22 @@ struct FloatToVec
     // Transform a scalar value into a vector value.
     static openvdb::Vec3s toVec(const ValueT& v) { return openvdb::Vec3s(v, v*2, v*3); }
 
-    FloatToVec() { numTiles = 0; }
+    FloatToVec() : numTiles{0} {}
+    FloatToVec(const FloatToVec& other) : numTiles{other.numTiles.load(std::memory_order_acquire)} {}
 
     void operator()(const InIterT& it, Accessor& acc)
     {
         if (it.isVoxelValue()) { // set a single voxel
             acc.setValue(it.getCoord(), toVec(*it));
         } else { // fill an entire tile
-            numTiles.fetch_and_increment();
+            numTiles.fetch_add(1);
             openvdb::CoordBBox bbox;
             it.getBoundingBox(bbox);
             acc.tree().fill(bbox, toVec(*it));
         }
     }
 
-    tbb::atomic<int> numTiles;
+    std::atomic<int> numTiles;
 };
 
 }
diff --git i/openvdb/openvdb/util/PagedArray.h w/openvdb/openvdb/util/PagedArray.h
index 036a336..2e09577 100644
--- i/openvdb/openvdb/util/PagedArray.h
+++ w/openvdb/openvdb/util/PagedArray.h
@@ -21,7 +21,7 @@
 #include <cassert>
 #include <iostream>
 #include <algorithm>// std::swap
-#include <tbb/atomic.h>
+#include <atomic>
 #include <tbb/spin_mutex.h>
 #include <tbb/parallel_for.h>
 #include <tbb/parallel_sort.h>
@@ -197,7 +197,7 @@ public:
     /// @warning Not thread-safe and mostly intended for debugging!
     size_t push_back_unsafe(const ValueType& value)
     {
-        const size_t index = mSize.fetch_and_increment();
+        const size_t index = mSize.fetch_add(1);
         if (index >= mCapacity) {
             mPageTable.push_back( new Page() );
             mCapacity += Page::Size;
@@ -456,7 +456,7 @@ private:
         }
     }
     PageTableT mPageTable;//holds points to allocated pages
-    tbb::atomic<size_t> mSize;// current number of elements in array
+    std::atomic<size_t> mSize;// current number of elements in array
     size_t mCapacity;//capacity of array given the current page count
     tbb::spin_mutex mGrowthMutex;//Mutex-lock required to grow pages
 }; // Public class PagedArray
diff --git i/openvdb/openvdb/viewer/Viewer.cc w/openvdb/openvdb/viewer/Viewer.cc
index 54dca68..02dcaa6 100644
--- i/openvdb/openvdb/viewer/Viewer.cc
+++ w/openvdb/openvdb/viewer/Viewer.cc
@@ -12,12 +12,12 @@
 #include <openvdb/points/PointDataGrid.h>
 #include <openvdb/points/PointCount.h>
 #include <openvdb/version.h> // for OPENVDB_LIBRARY_MAJOR_VERSION, etc.
-#include <tbb/atomic.h>
-#include <tbb/mutex.h>
+#include <atomic>
 #include <cmath> // for fabs()
 #include <iomanip> // for std::setprecision()
 #include <iostream>
 #include <memory>
+#include <mutex>
 #include <sstream>
 #include <vector>
 #include <limits>
@@ -109,7 +109,7 @@ private:
     void doView();
     static void* doViewTask(void* arg);
 
-    tbb::atomic<bool> mRedisplay;
+    std::atomic<bool> mRedisplay;
     bool mClose, mHasThread;
     std::thread mThread;
     openvdb::GridCPtrVec mGrids;
@@ -123,7 +123,7 @@ namespace {
 
 ViewerImpl* sViewer = nullptr;
 ThreadManager* sThreadMgr = nullptr;
-tbb::mutex sLock;
+std::mutex sLock;
 
 
 void
@@ -177,7 +177,7 @@ Viewer
 init(const std::string& progName, bool background)
 {
     if (sViewer == nullptr) {
-        tbb::mutex::scoped_lock lock(sLock);
+        std::lock_guard<std::mutex> lock(sLock);
         if (sViewer == nullptr) {
             OPENVDB_START_THREADSAFE_STATIC_WRITE
             sViewer = new ViewerImpl;
@@ -188,7 +188,7 @@ init(const std::string& progName, bool background)
 
     if (background) {
         if (sThreadMgr == nullptr) {
-            tbb::mutex::scoped_lock lock(sLock);
+            std::lock_guard<std::mutex> lock(sLock);
             if (sThreadMgr == nullptr) {
                 OPENVDB_START_THREADSAFE_STATIC_WRITE
                 sThreadMgr = new ThreadManager;
@@ -197,7 +197,7 @@ init(const std::string& progName, bool background)
         }
     } else {
         if (sThreadMgr != nullptr) {
-            tbb::mutex::scoped_lock lock(sLock);
+            std::lock_guard<std::mutex> lock(sLock);
             delete sThreadMgr;
             OPENVDB_START_THREADSAFE_STATIC_WRITE
             sThreadMgr = nullptr;
@@ -328,7 +328,10 @@ ThreadManager::doView()
     // This function runs in its own thread.
     // The mClose and mRedisplay flags are set from the main thread.
     while (!mClose) {
-        if (mRedisplay.compare_and_swap(/*set to*/false, /*if*/true)) {
+        // If mRedisplay was true, then set it to false
+        // and then, if sViewer, call view:
+        bool expected = true;
+        if (mRedisplay.compare_exchange_strong(expected, false)) {
             if (sViewer) sViewer->view(mGrids);
         }
         sViewer->sleep(0.5/*sec*/);
diff --git i/openvdb_ax/openvdb_ax/ast/Parse.cc w/openvdb_ax/openvdb_ax/ast/Parse.cc
index f319b4e..7b0d73e 100644
--- i/openvdb_ax/openvdb_ax/ast/Parse.cc
+++ w/openvdb_ax/openvdb_ax/ast/Parse.cc
@@ -14,13 +14,13 @@
 #include "../grammar/generated/axparser.h"
 #endif
 
-#include <tbb/mutex.h>
+#include <mutex>
 #include <string>
 #include <memory>
 
 namespace {
 // Declare this at file scope to ensure thread-safe initialization.
-tbb::mutex sInitMutex;
+std::mutex sInitMutex;
 }
 
 openvdb::ax::Logger* axlog = nullptr;
@@ -38,7 +38,7 @@ extern void axerror (openvdb::ax::ast::Tree**, char const *s) {
 openvdb::ax::ast::Tree::ConstPtr
 openvdb::ax::ast::parse(const char* code, openvdb::ax::Logger& logger)
 {
-    tbb::mutex::scoped_lock lock(sInitMutex);
+    std::lock_guard<std::mutex> lock(sInitMutex);
     axlog = &logger; // for lexer errs
     logger.setSourceCode(code);
 
diff --git i/openvdb_ax/openvdb_ax/ax.cc w/openvdb_ax/openvdb_ax/ax.cc
index 6e6b51c..bef9f4c 100644
--- i/openvdb_ax/openvdb_ax/ax.cc
+++ w/openvdb_ax/openvdb_ax/ax.cc
@@ -15,7 +15,7 @@
 #include <llvm/Support/ManagedStatic.h> // llvm_shutdown
 #include <llvm/ExecutionEngine/MCJIT.h> // LLVMLinkInMCJIT
 
-#include <tbb/mutex.h>
+#include <mutex>
 
 namespace openvdb {
 OPENVDB_USE_VERSION_NAMESPACE
@@ -107,20 +107,20 @@ void run(const char* ax, openvdb::GridPtrVec& grids)
 
 namespace {
 // Declare this at file scope to ensure thread-safe initialization.
-tbb::mutex sInitMutex;
+std::mutex sInitMutex;
 bool sIsInitialized = false;
 bool sShutdown = false;
 }
 
 bool isInitialized()
 {
-    tbb::mutex::scoped_lock lock(sInitMutex);
+    std::lock_guard<std::mutex> lock(sInitMutex);
     return sIsInitialized;
 }
 
 void initialize()
 {
-    tbb::mutex::scoped_lock lock(sInitMutex);
+    std::lock_guard<std::mutex> lock(sInitMutex);
     if (sIsInitialized) return;
 
     if (sShutdown) {
@@ -189,7 +189,7 @@ void initialize()
 
 void uninitialize()
 {
-    tbb::mutex::scoped_lock lock(sInitMutex);
+    std::lock_guard<std::mutex> lock(sInitMutex);
     if (!sIsInitialized) return;
 
     // @todo consider replacing with storage to Support/InitLLVM
diff --git i/openvdb_houdini/openvdb_houdini/GR_PrimVDBPoints.cc w/openvdb_houdini/openvdb_houdini/GR_PrimVDBPoints.cc
index fa63108..b394835 100644
--- i/openvdb_houdini/openvdb_houdini/GR_PrimVDBPoints.cc
+++ w/openvdb_houdini/openvdb_houdini/GR_PrimVDBPoints.cc
@@ -31,10 +31,9 @@
 #include <UT/UT_DSOVersion.h>
 #include <UT/UT_UniquePtr.h>
 
-#include <tbb/mutex.h>
-
 #include <iostream>
 #include <limits>
+#include <mutex>
 #include <sstream>
 #include <string>
 #include <utility>
@@ -58,7 +57,7 @@ namespace {
 /// @note The render hook guard should not be required..
 
 // Declare this at file scope to ensure thread-safe initialization.
-tbb::mutex sRenderHookRegistryMutex;
+std::mutex sRenderHookRegistryMutex;
 bool renderHookRegistered = false;
 
 } // anonymous namespace
@@ -174,7 +173,7 @@ private:
 void
 newRenderHook(DM_RenderTable* table)
 {
-    tbb::mutex::scoped_lock lock(sRenderHookRegistryMutex);
+    std::lock_guard<std::mutex> lock(sRenderHookRegistryMutex);
 
     if (!renderHookRegistered) {
 
diff --git i/openvdb_houdini/openvdb_houdini/SOP_NodeVDB.cc w/openvdb_houdini/openvdb_houdini/SOP_NodeVDB.cc
index 08b75fb..ca64078 100644
--- i/openvdb_houdini/openvdb_houdini/SOP_NodeVDB.cc
+++ w/openvdb_houdini/openvdb_houdini/SOP_NodeVDB.cc
@@ -21,13 +21,12 @@
 #include <SYS/SYS_Version.h>
 #include <UT/UT_InfoTree.h>
 #include <UT/UT_SharedPtr.h>
-#include <tbb/mutex.h>
 #include <algorithm>
 #include <cctype> // std::tolower
 #include <iostream>
 #include <map>
 #include <memory>
-#include <mutex> // std::call_once
+#include <mutex>
 #include <sstream>
 #include <stdexcept>
 
@@ -100,8 +99,6 @@ namespace openvdb_houdini {
 
 namespace node_info_text {
 
-using Mutex = tbb::mutex;
-using Lock = Mutex::scoped_lock;
 // map of function callbacks to grid types
 using ApplyGridSpecificInfoTextMap = std::map<openvdb::Name, ApplyGridSpecificInfoText>;
 
@@ -110,18 +107,18 @@ struct LockedInfoTextRegistry
     LockedInfoTextRegistry() {}
     ~LockedInfoTextRegistry() {}
 
-    Mutex mMutex;
+    std::mutex mMutex;
     ApplyGridSpecificInfoTextMap mApplyGridSpecificInfoTextMap;
 };
 
 // Declare this at file scope to ensure thread-safe initialization
-static Mutex theInitInfoTextRegistryMutex;
+static std::mutex theInitInfoTextRegistryMutex;
 
 // Global function for accessing the regsitry
 static LockedInfoTextRegistry*
 getInfoTextRegistry()
 {
-    Lock lock(theInitInfoTextRegistryMutex);
+    std::lock_guard<std::mutex> lock(theInitInfoTextRegistryMutex);
 
     static LockedInfoTextRegistry *registry = nullptr;
 
@@ -147,7 +144,7 @@ void
 registerGridSpecificInfoText(const std::string& gridType, ApplyGridSpecificInfoText callback)
 {
     LockedInfoTextRegistry *registry = getInfoTextRegistry();
-    Lock lock(registry->mMutex);
+    std::lock_guard<std::mutex> lock(registry->mMutex);
 
     if(registry->mApplyGridSpecificInfoTextMap.find(gridType) !=
        registry->mApplyGridSpecificInfoTextMap.end()) return;
@@ -162,7 +159,7 @@ ApplyGridSpecificInfoText
 getGridSpecificInfoText(const std::string& gridType)
 {
     LockedInfoTextRegistry *registry = getInfoTextRegistry();
-    Lock lock(registry->mMutex);
+    std::lock_guard<std::mutex> lock(registry->mMutex);
 
     const ApplyGridSpecificInfoTextMap::const_iterator iter =
         registry->mApplyGridSpecificInfoTextMap.find(gridType);
diff --git i/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Rasterize_Points.cc w/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Rasterize_Points.cc
index 1d8bd02..0e1b4d8 100644
--- i/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Rasterize_Points.cc
+++ w/openvdb_houdini/openvdb_houdini/SOP_OpenVDB_Rasterize_Points.cc
@@ -47,7 +47,6 @@
 #include <VOP/VOP_ExportedParmsManager.h>
 #include <VOP/VOP_LanguageContextTypeList.h>
 
-#include <tbb/atomic.h>
 #include <tbb/blocked_range.h>
 #include <tbb/enumerable_thread_specific.h>
 #include <tbb/parallel_for.h>
@@ -59,6 +58,7 @@
 #include <hboost/algorithm/string/split.hpp>
 
 #include <algorithm> // std::sort
+#include <atomic>
 #include <cmath> // trigonometric functions
 #include <memory>
 #include <set>
@@ -1954,7 +1954,7 @@ private:
     UT_WorkArgs mVexArgs;
     const size_t mMaxArraySize;
     fpreal mTime, mTimeInc, mFrame;
-    tbb::atomic<int> mIsTimeDependant;
+    std::atomic<int> mIsTimeDependant;
     GU_VexGeoInputs mVexInputs;
 };
 
diff --git i/openvdb_maya/openvdb_maya/OpenVDBPlugin.cc w/openvdb_maya/openvdb_maya/OpenVDBPlugin.cc
index 0fcbcda..3d559f8 100644
--- i/openvdb_maya/openvdb_maya/OpenVDBPlugin.cc
+++ w/openvdb_maya/openvdb_maya/OpenVDBPlugin.cc
@@ -23,8 +23,7 @@
 #include <maya/MPlug.h>
 #include <maya/MFnPluginData.h>
 
-#include <tbb/mutex.h>
-
+#include <mutex>
 #include <vector>
 #include <sstream>
 #include <string>
