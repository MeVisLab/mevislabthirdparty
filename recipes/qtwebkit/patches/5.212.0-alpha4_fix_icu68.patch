diff --git i/Source/WebCore/platform/text/LocaleICU.cpp w/Source/WebCore/platform/text/LocaleICU.cpp
index 6fbe495..9ae0058 100644
--- i/Source/WebCore/platform/text/LocaleICU.cpp
+++ w/Source/WebCore/platform/text/LocaleICU.cpp
@@ -153,12 +153,12 @@ static String getDateFormatPattern(const UDateFormat* dateFormat)
         return emptyString();
 
     UErrorCode status = U_ZERO_ERROR;
-    int32_t length = udat_toPattern(dateFormat, TRUE, 0, 0, &status);
+    int32_t length = udat_toPattern(dateFormat, true, 0, 0, &status);
     if (status != U_BUFFER_OVERFLOW_ERROR || !length)
         return emptyString();
     Vector<UChar> buffer(length);
     status = U_ZERO_ERROR;
-    udat_toPattern(dateFormat, TRUE, buffer.data(), length, &status);
+    udat_toPattern(dateFormat, true, buffer.data(), length, &status);
     if (U_FAILURE(status))
         return emptyString();
     return String::adopt(buffer);
diff --git i/Source/WebCore/platform/text/TextCodecICU.cpp w/Source/WebCore/platform/text/TextCodecICU.cpp
index dd6ff06..dbc2f16 100644
--- i/Source/WebCore/platform/text/TextCodecICU.cpp
+++ w/Source/WebCore/platform/text/TextCodecICU.cpp
@@ -21,7 +21,7 @@
  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #include "config.h"
@@ -85,13 +85,13 @@ void TextCodecICU::registerEncodingNames(EncodingNameRegistrar registrar)
         const char* canonicalConverterName = ucnv_getAvailableName(i);
         UErrorCode error = U_ZERO_ERROR;
         // Try MIME before trying IANA to pick up commonly used names like
-        // 'EUC-JP' instead of horrendously long names like 
-        // 'Extended_UNIX_Code_Packed_Format_for_Japanese'. 
+        // 'EUC-JP' instead of horrendously long names like
+        // 'Extended_UNIX_Code_Packed_Format_for_Japanese'.
         const char* webStandardName = ucnv_getStandardName(canonicalConverterName, "MIME", &error);
         if (!U_SUCCESS(error) || !webStandardName) {
             error = U_ZERO_ERROR;
             // Try IANA to pick up 'windows-12xx' and other names
-            // which are not preferred MIME names but are widely used. 
+            // which are not preferred MIME names but are widely used.
             webStandardName = ucnv_getStandardName(canonicalConverterName, "IANA", &error);
             if (!U_SUCCESS(error) || !webStandardName)
                 continue;
@@ -308,7 +308,7 @@ void TextCodecICU::createICUConverter() const
     m_converterICU = ucnv_open(m_canonicalConverterName, &err);
     ASSERT(U_SUCCESS(err));
     if (m_converterICU)
-        ucnv_setFallback(m_converterICU, TRUE);
+        ucnv_setFallback(m_converterICU, true);
 }
 
 int TextCodecICU::decodeToBuffer(UChar* target, UChar* targetLimit, const char*& source, const char* sourceLimit, int32_t* offsets, bool flush, UErrorCode& err)
@@ -366,7 +366,7 @@ String TextCodecICU::decode(const char* bytes, size_t length, bool flush, bool s
             return String();
         }
     }
-    
+
     ErrorCallbackSetter callbackSetter(m_converterICU, stopOnError);
 
     StringBuilder result;
@@ -436,7 +436,7 @@ static void urlEscapedEntityCallback(const void* context, UConverterFromUnicodeA
 
 // Substitutes special GBK characters, escaping all other unassigned entities.
 static void gbkCallbackEscape(const void* context, UConverterFromUnicodeArgs* fromUArgs, const UChar* codeUnits, int32_t length,
-    UChar32 codePoint, UConverterCallbackReason reason, UErrorCode* err) 
+    UChar32 codePoint, UConverterCallbackReason reason, UErrorCode* err)
 {
     UChar outChar;
     if (reason == UCNV_UNASSIGNED && (outChar = fallbackForGBK(codePoint))) {
@@ -450,7 +450,7 @@ static void gbkCallbackEscape(const void* context, UConverterFromUnicodeArgs* fr
 
 // Combines both gbkUrlEscapedEntityCallback and GBK character substitution.
 static void gbkUrlEscapedEntityCallack(const void* context, UConverterFromUnicodeArgs* fromUArgs, const UChar* codeUnits, int32_t length,
-    UChar32 codePoint, UConverterCallbackReason reason, UErrorCode* err) 
+    UChar32 codePoint, UConverterCallbackReason reason, UErrorCode* err)
 {
     if (reason == UCNV_UNASSIGNED) {
         if (UChar outChar = fallbackForGBK(codePoint)) {
@@ -466,7 +466,7 @@ static void gbkUrlEscapedEntityCallack(const void* context, UConverterFromUnicod
 }
 
 static void gbkCallbackSubstitute(const void* context, UConverterFromUnicodeArgs* fromUArgs, const UChar* codeUnits, int32_t length,
-    UChar32 codePoint, UConverterCallbackReason reason, UErrorCode* err) 
+    UChar32 codePoint, UConverterCallbackReason reason, UErrorCode* err)
 {
     UChar outChar;
     if (reason == UCNV_UNASSIGNED && (outChar = fallbackForGBK(codePoint))) {
diff --git i/Source/WebCore/platform/text/icu/UTextProvider.h w/Source/WebCore/platform/text/icu/UTextProvider.h
index c254fc4..6d1e1cb 100644
--- i/Source/WebCore/platform/text/icu/UTextProvider.h
+++ w/Source/WebCore/platform/text/icu/UTextProvider.h
@@ -80,12 +80,12 @@ inline bool uTextAccessInChunkOrOutOfRange(UText* text, int64_t nativeIndex, int
             // Ensure chunk offset is well formed if computed offset exceeds int32_t range.
             ASSERT(offset < std::numeric_limits<int32_t>::max());
             text->chunkOffset = offset < std::numeric_limits<int32_t>::max() ? static_cast<int32_t>(offset) : 0;
-            isAccessible = TRUE;
+            isAccessible = true;
             return true;
         }
         if (nativeIndex >= nativeLength && text->chunkNativeLimit == nativeLength) {
             text->chunkOffset = text->chunkLength;
-            isAccessible = FALSE;
+            isAccessible = false;
             return true;
         }
     } else {
@@ -94,12 +94,12 @@ inline bool uTextAccessInChunkOrOutOfRange(UText* text, int64_t nativeIndex, int
             // Ensure chunk offset is well formed if computed offset exceeds int32_t range.
             ASSERT(offset < std::numeric_limits<int32_t>::max());
             text->chunkOffset = offset < std::numeric_limits<int32_t>::max() ? static_cast<int32_t>(offset) : 0;
-            isAccessible = TRUE;
+            isAccessible = true;
             return true;
         }
         if (nativeIndex <= 0 && !text->chunkNativeStart) {
             text->chunkOffset = 0;
-            isAccessible = FALSE;
+            isAccessible = false;
             return true;
         }
     }
diff --git i/Source/WebCore/platform/text/icu/UTextProviderLatin1.cpp w/Source/WebCore/platform/text/icu/UTextProviderLatin1.cpp
index cd6852c..166c7de 100644
--- i/Source/WebCore/platform/text/icu/UTextProviderLatin1.cpp
+++ w/Source/WebCore/platform/text/icu/UTextProviderLatin1.cpp
@@ -70,9 +70,9 @@ static UText* uTextLatin1Clone(UText* destination, const UText* source, UBool de
     UText* result = utext_setup(destination, sizeof(UChar) * UTextWithBufferInlineCapacity, status);
     if (U_FAILURE(*status))
         return destination;
-    
+
     result->providerProperties = source->providerProperties;
-    
+
     // Point at the same position, but with an empty buffer.
     result->chunkNativeStart = source->chunkNativeStart;
     result->chunkNativeLimit = source->chunkNativeStart;
@@ -100,26 +100,26 @@ static UBool uTextLatin1Access(UText* uText, int64_t index, UBool forward)
         if (index < uText->chunkNativeLimit && index >= uText->chunkNativeStart) {
             // Already inside the buffer. Set the new offset.
             uText->chunkOffset = static_cast<int32_t>(index - uText->chunkNativeStart);
-            return TRUE;
+            return true;
         }
         if (index >= length && uText->chunkNativeLimit == length) {
             // Off the end of the buffer, but we can't get it.
             uText->chunkOffset = static_cast<int32_t>(index - uText->chunkNativeStart);
-            return FALSE;
+            return false;
         }
     } else {
         if (index <= uText->chunkNativeLimit && index > uText->chunkNativeStart) {
             // Already inside the buffer. Set the new offset.
             uText->chunkOffset = static_cast<int32_t>(index - uText->chunkNativeStart);
-            return TRUE;
+            return true;
         }
         if (!index && !uText->chunkNativeStart) {
             // Already at the beginning; can't go any farther.
             uText->chunkOffset = 0;
-            return FALSE;
+            return false;
         }
     }
-    
+
     if (forward) {
         uText->chunkNativeStart = index;
         uText->chunkNativeLimit = uText->chunkNativeStart + UTextWithBufferInlineCapacity;
@@ -144,7 +144,7 @@ static UBool uTextLatin1Access(UText* uText, int64_t index, UBool forward)
 
     uText->nativeIndexingLimit = uText->chunkLength;
 
-    return TRUE;
+    return true;
 }
 
 static int32_t uTextLatin1Extract(UText* uText, int64_t start, int64_t limit, UChar* dest, int32_t destCapacity, UErrorCode* status)
@@ -169,7 +169,7 @@ static int32_t uTextLatin1Extract(UText* uText, int64_t start, int64_t limit, UC
         limit = length;
 
     length = limit - start;
-    
+
     if (!length)
         return 0;
 
@@ -336,7 +336,7 @@ static int64_t uTextLatin1ContextAwareNativeLength(UText* text)
 static UBool uTextLatin1ContextAwareAccess(UText* text, int64_t nativeIndex, UBool forward)
 {
     if (!text->context)
-        return FALSE;
+        return false;
     int64_t nativeLength = uTextLatin1ContextAwareNativeLength(text);
     UBool isAccessible;
     if (uTextAccessInChunkOrOutOfRange(text, nativeIndex, nativeLength, forward, isAccessible))
@@ -356,7 +356,7 @@ static UBool uTextLatin1ContextAwareAccess(UText* text, int64_t nativeIndex, UBo
         ASSERT(newContext == UTextProviderContext::PriorContext);
         textLatin1ContextAwareSwitchToPriorContext(text, nativeIndex, nativeLength, forward);
     }
-    return TRUE;
+    return true;
 }
 
 static int32_t uTextLatin1ContextAwareExtract(UText*, int64_t, int64_t, UChar*, int32_t, UErrorCode* errorCode)
diff --git i/Source/WebCore/platform/text/icu/UTextProviderUTF16.cpp w/Source/WebCore/platform/text/icu/UTextProviderUTF16.cpp
index 7aaac48..9ae0d36 100644
--- i/Source/WebCore/platform/text/icu/UTextProviderUTF16.cpp
+++ w/Source/WebCore/platform/text/icu/UTextProviderUTF16.cpp
@@ -125,7 +125,7 @@ static inline int64_t uTextUTF16ContextAwareNativeLength(UText* text)
 static UBool uTextUTF16ContextAwareAccess(UText* text, int64_t nativeIndex, UBool forward)
 {
     if (!text->context)
-        return FALSE;
+        return false;
     int64_t nativeLength = uTextUTF16ContextAwareNativeLength(text);
     UBool isAccessible;
     if (uTextAccessInChunkOrOutOfRange(text, nativeIndex, nativeLength, forward, isAccessible))
@@ -145,7 +145,7 @@ static UBool uTextUTF16ContextAwareAccess(UText* text, int64_t nativeIndex, UBoo
         ASSERT(newContext == UTextProviderContext::PriorContext);
         textUTF16ContextAwareSwitchToPriorContext(text, nativeIndex, nativeLength, forward);
     }
-    return TRUE;
+    return true;
 }
 
 static int32_t uTextUTF16ContextAwareExtract(UText*, int64_t, int64_t, UChar*, int32_t, UErrorCode* errorCode)
